/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
#[must_use]
pub struct cxx_status_code_system {
    pub domain: *mut ::std::os::raw::c_void,
    pub value: isize,
}
impl Default for cxx_status_code_system {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The return type of many monad C functions that can fail; this type\n interoperates with the Boost.Outcome C++ library; it is layout compatible\n with the `status_result<intptr_t>` type from that library"]
pub type monad_c_result = cxx_result_status_code_system_monad;
#[doc = " Provides the complete type definition for `monad_c_result` (which is\n otherwise incomplete) and the various inline functions that form its\n public interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cxx_result_status_code_system_monad {
    #[doc = " Provides the complete type definition for `monad_c_result` (which is\n otherwise incomplete) and the various inline functions that form its\n public interface"]
    pub value: isize,
    pub flags: ::std::os::raw::c_uint,
    pub error: cxx_status_code_system,
}
impl Default for cxx_result_status_code_system_monad {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Return a successful `monad_c_result` for a given `intptr_t`"]
    pub fn monad_c_make_success(value: isize) -> monad_c_result;
}
extern "C" {
    #[doc = " Return a failure `monad_c_result` with the given `errno` domain code"]
    pub fn monad_c_make_failure(ec: isize) -> monad_c_result;
}
#[doc = "! \\brief A type representing the tick count on the CPU"]
pub type monad_context_cpu_ticks_count_t = u64;
pub const monad_async_priority_monad_async_priority_high: monad_async_priority = 0;
pub const monad_async_priority_monad_async_priority_normal: monad_async_priority = 1;
pub const monad_async_priority_monad_async_priority_low: monad_async_priority = 2;
pub const monad_async_priority_monad_async_priority_max: monad_async_priority = 3;
pub const monad_async_priority_monad_async_priority_unchanged: monad_async_priority = 255;
#[doc = "! \\brief Task priority classes"]
pub type monad_async_priority = ::std::os::raw::c_uchar;
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::std::os::raw::c_uint;
pub type atomic_uint = u32;
pub type monad_context = *mut monad_context_head;
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_context_task_head {
    #[doc = "! \\brief The body of the task"]
    pub user_code: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut monad_context_task_head) -> monad_c_result,
    >,
    #[doc = "! \\brief Any user defined value"]
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = "! \\brief The context for the running task"]
    pub context: monad_context,
    #[doc = "! \\brief Set to the result of the task on exit; also used as scratch\n! during the task's suspend-resume cycles"]
    pub result: monad_c_result,
    #[doc = "! \\brief Set by the task implementation to a task detach implementation"]
    pub detach: ::std::option::Option<unsafe extern "C" fn(task: *mut monad_context_task_head)>,
}
impl Default for monad_context_task_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a task"]
pub type monad_context_task = *mut monad_context_task_head;
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_context_task_attr {
    #[doc = "! \\brief 0 chooses platform default stack size"]
    pub stack_size: usize,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_context_switcher_head {
    pub user_ptr: *mut ::std::os::raw::c_void,
    #[doc = "! The number of contexts existing"]
    pub contexts: atomic_uint,
    #[doc = "! \\brief Destroys self"]
    pub self_destroy: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_context_switcher_head) -> monad_c_result,
    >,
    #[doc = "! \\brief Create a switchable context for a task"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut monad_context,
            switcher: *mut monad_context_switcher_head,
            task: monad_context_task,
            attr: *const monad_context_task_attr,
        ) -> monad_c_result,
    >,
    #[doc = "! \\brief Destroys a switchable context"]
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(context: monad_context) -> monad_c_result>,
    #[doc = " \\brief If running within a switchable context, suspend it and call\nresume on the new context via its context switcher.\n\nNote that calling this from the main context will not work, as you will have\nno `current_context`. If in the main context, use `resume_many()` to\nget a suitable `current_context`.\n\nThis call differs from `resume()` by being able to cope with `new_context`\nhaving a different context switcher to the current context. If the\nnew context's switcher could be different from the current context's\nswitcher, you must use this call."]
    pub suspend_and_call_resume: ::std::option::Option<
        unsafe extern "C" fn(current_context: monad_context, new_context: monad_context),
    >,
    #[doc = " \\brief Resume execution of a previously suspended switchable context.\n\nGenerally this should only be called from within `resume_many()`'s\n`resumed()` callback, and not otherwise as you won't know if the new\ncontext's switcher is the same as the current context's.\n`suspend_and_call_resume()` does check if the switchers are identical and/or\nare of the same kind but different instances, and if so will take an\noptimised path."]
    pub resume: ::std::option::Option<
        unsafe extern "C" fn(current_context: monad_context, new_context: monad_context),
    >,
    #[doc = " \\brief To avoid having to set a resumption point per task when resuming\nmany tasks from the central loop of the executor, set a single\nresumption point and call the supplied function every time a task\nresumed within the supplied function suspends. This can be very\nconsiderably more efficient for some types of context switcher.\n\nGenerally you call `resume()` from within `resumed()` as the context\nswitcher of the new context will be `switcher`."]
    pub resume_many: ::std::option::Option<
        unsafe extern "C" fn(
            switcher: *mut monad_context_switcher_head,
            resumed: ::std::option::Option<
                unsafe extern "C" fn(
                    user_ptr: *mut ::std::os::raw::c_void,
                    current_context_to_use_when_resuming: monad_context,
                ) -> monad_c_result,
            >,
            user_ptr: *mut ::std::os::raw::c_void,
        ) -> monad_c_result,
    >,
}
impl Default for monad_context_switcher_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type monad_context_switcher = *mut monad_context_switcher_head;
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_context_switcher_impl {
    #[doc = "! \\brief Create a switcher of contexts. The\n! executor creates one of these per executor."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(switcher: *mut monad_context_switcher) -> monad_c_result,
    >,
}
#[repr(C)]
pub struct monad_context_head {
    pub is_running: bool,
    pub is_suspended: bool,
    pub switcher: u64,
    pub thread_db_slot: usize,
    pub sanitizer: monad_context_head__bindgen_ty_1,
}
#[repr(C)]
pub struct monad_context_head__bindgen_ty_1 {
    pub __bindgen_anon_1: monad_context_head__bindgen_ty_1__bindgen_ty_1,
    pub bottom: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[repr(C)]
pub struct monad_context_head__bindgen_ty_1__bindgen_ty_1 {
    pub fake_stack_save: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub valgrind_stack_id: __BindgenUnionField<::std::os::raw::c_uint>,
    pub fiber: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
impl Default for monad_context_head__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_context_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_context_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "! \\brief For a context currently suspended, change which context switcher to\n! use for the next resumption. Context switchers must be of same type."]
    pub fn monad_context_reparent_switcher(
        context: monad_context,
        new_switcher: monad_context_switcher,
    );
}
extern "C" {
    #[doc = "! \\brief Destroys any context switcher"]
    pub fn monad_context_switcher_destroy(switcher: monad_context_switcher) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Creates a `setjmp`/`longjmp` based context switcher with each task\ngetting its own stack.\n\nNote that an instance of this is NOT threadsafe, so you must either lock\na mutex around switching contexts using this context switcher or have a\ncontext switcher instance per thread."]
    pub fn monad_context_switcher_sjlj_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a `setjmp`/`longjmp` based context\n! switcher"]
    pub static monad_context_switcher_sjlj: monad_context_switcher_impl;
}
extern "C" {
    #[doc = " \\brief Creates a none context switcher which can't suspend-resume. Useful\nfor threadpool implementation.\n\nAs this context switcher never suspends and resumes, it is safe to use a single\ninstance of this across multiple threads. In fact, the current implementation\nalways returns a static instance, and destruction does nothing. You may\ntherefore find `monad_context_switcher_none_instance()` more useful."]
    pub fn monad_context_switcher_none_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a none context\n! switcher"]
    pub static monad_context_switcher_none: monad_context_switcher_impl;
}
extern "C" {
    #[doc = "! \\brief Convenience obtainer of the static none context switcher."]
    pub fn monad_context_switcher_none_instance() -> monad_context_switcher;
}
extern "C" {
    #[doc = " \\brief Creates a `fcontext` based context switcher with each task\ngetting its own stack. This is approx 2x faster than the `setjmp`/`longjmp`\ncontext switcher if in a hot loop\n\nNote that an instance of this is NOT threadsafe, so you must either lock\na mutex around switching contexts using this context switcher or have a\ncontext switcher instance per thread."]
    pub fn monad_context_switcher_fcontext_create(
        switcher: *mut monad_context_switcher,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Convenience struct for setting a `fcontext` based context\n! switcher"]
    pub static monad_context_switcher_fcontext: monad_context_switcher_impl;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_sqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub flags: __u32,
    pub dropped: __u32,
    pub array: __u32,
    pub resv1: __u32,
    pub user_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_cqring_offsets {
    pub head: __u32,
    pub tail: __u32,
    pub ring_mask: __u32,
    pub ring_entries: __u32,
    pub overflow: __u32,
    pub cqes: __u32,
    pub flags: __u32,
    pub resv1: __u32,
    pub user_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_uring_params {
    pub sq_entries: __u32,
    pub cq_entries: __u32,
    pub flags: __u32,
    pub sq_thread_cpu: __u32,
    pub sq_thread_idle: __u32,
    pub features: __u32,
    pub wq_fd: __u32,
    pub resv: [__u32; 3usize],
    pub sq_off: io_sqring_offsets,
    pub cq_off: io_cqring_offsets,
}
#[doc = "! \\brief The public attributes of an executor"]
pub type monad_async_executor = *mut monad_async_executor_head;
pub type monad_async_task = *mut monad_async_task_head;
#[doc = "! \\brief An i/o status state used to identify an i/o in progress. Must NOT\n! move in memory until the operation completes."]
#[repr(C)]
pub struct monad_async_io_status {
    pub prev: *mut monad_async_io_status,
    pub next: *mut monad_async_io_status,
    pub cancel_: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: monad_async_task,
            arg2: *mut monad_async_io_status,
        ) -> monad_c_result,
    >,
    pub __bindgen_anon_1: monad_async_io_status__bindgen_ty_1,
    pub ticks_when_initiated: monad_context_cpu_ticks_count_t,
    pub ticks_when_completed: monad_context_cpu_ticks_count_t,
    pub ticks_when_reaped: monad_context_cpu_ticks_count_t,
}
#[repr(C)]
pub struct monad_async_io_status__bindgen_ty_1 {
    #[doc = "! Unspecified value immediately after initiating call returns. Will\n! become bytes transferred if operation is successful, or another\n! error if it fails or is cancelled."]
    pub result: __BindgenUnionField<monad_c_result>,
    pub __bindgen_anon_1: __BindgenUnionField<monad_async_io_status__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_io_status__bindgen_ty_1__bindgen_ty_1 {
    pub task_: monad_async_task,
    pub flags_: ::std::os::raw::c_uint,
    pub tofill_: *mut monad_async_task_registered_io_buffer,
}
impl Default for monad_async_io_status__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_io_status__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_io_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a task"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_head {
    pub derived: monad_context_task_head,
    pub io_recipient_task: *mut monad_async_task_head,
    pub priority: monad_async_task_head__bindgen_ty_1,
    pub current_executor: u64,
    pub is_awaiting_dispatch: u8,
    pub is_pending_launch: u8,
    pub is_running: u8,
    pub is_suspended_sqe_exhaustion: u8,
    pub is_suspended_sqe_exhaustion_wr: u8,
    pub is_suspended_awaiting: u8,
    pub is_suspended_completed: u8,
    pub ticks_when_submitted: monad_context_cpu_ticks_count_t,
    pub ticks_when_attached: monad_context_cpu_ticks_count_t,
    pub ticks_when_detached: monad_context_cpu_ticks_count_t,
    pub ticks_when_suspended_awaiting: monad_context_cpu_ticks_count_t,
    pub ticks_when_suspended_completed: monad_context_cpu_ticks_count_t,
    pub ticks_when_resumed: monad_context_cpu_ticks_count_t,
    pub total_ticks_executed: monad_context_cpu_ticks_count_t,
    pub io_submitted: ::std::os::raw::c_uint,
    pub io_completed_not_reaped: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_head__bindgen_ty_1 {
    pub cpu: monad_async_priority,
    pub io: monad_async_priority,
}
impl Default for monad_async_task_head__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for monad_async_task_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Attributes by which to construct a task"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_task_attr {
    pub derived: monad_context_task_attr,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a task instance using the specified context\n! switcher."]
    pub fn monad_async_task_create(
        task: *mut monad_async_task,
        switcher: monad_context_switcher,
        attr: *mut monad_async_task_attr,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a task instance. If the task is currently\n! suspended, it will be cancelled first in which case `EAGAIN` may be returned\n! from this function until cancellation succeeds."]
    pub fn monad_async_task_destroy(task: monad_async_task) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Initiate the transfer of a task's context's execution to a different\ntype of executor.\n\nThis function suspends the execution of the task and requests its executor to\noptionally take a copy of the public information of the task into `opt_save` so\nit can be restored later (this preserves tick counts etc), detach the task from\nthe executor, and then invoke the supplied function with the now 'naked' task.\nAnother type of executor may then overwrite the bytes after `monad_context_task`\nup to `MONAD_CONTEXT_TASK_ALLOCATION_SIZE`. If you need to pass your `to_invoke`\nadditional state, remember there is a `user_ptr` in `monad_context_task`.\n\nRemember that when the context resumes execution in the new executor, anything\nrelated to `monad_async_*` no longer applies. You can choose the return value of\nthis function by setting `task->head.derived.result` before resuming the\ncontext.\n\nIf your context wishes to return to this executor later, consider using\n`monad_async_task_from_foreign_context()` followed by\n`monad_async_task_attach()`."]
    pub fn monad_async_task_suspend_save_detach_and_invoke(
        task: monad_async_task,
        opt_save: monad_async_task,
        to_invoke: ::std::option::Option<
            unsafe extern "C" fn(detached_task: monad_context_task) -> monad_c_result,
        >,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Optionally copies the `monad_async_*` parts of `opt_save` into\n! `context_task`, and returns it as a `monad_async_task`."]
    pub fn monad_async_task_from_foreign_context(
        context_task: monad_context_task,
        opt_save: monad_async_task,
    ) -> monad_async_task;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Attaches a task instance onto a given executor, which\n! means it will launch the next time the executor runs. If the task is\n! attached already to a different executor, you MUST call this function from\n! that executor's kernel thread. If you optionally choose to reparent the\n! task's context to a new context switcher instance (typical if attaching\n! to an executor on a different kernel thread), it MUST be the same type of\n! context switcher."]
    pub fn monad_async_task_attach(
        executor: monad_async_executor,
        task: monad_async_task,
        opt_reparent_switcher: monad_context_switcher,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE If a task is currently suspended on an operation, cancel\n! it. This can take some time for the relevant io_uring operation to also\n! cancel. If the task is yet to launch, don't launch it. If the task isn't\n! currently running, do nothing. The suspension point will return\n! `ECANCELED` next time the cancelled task resumes."]
    pub fn monad_async_task_cancel(
        executor: monad_async_executor,
        task: monad_async_task,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Change the CPU or i/o priority of a task"]
    pub fn monad_async_task_set_priorities(
        task: monad_async_task,
        cpu: monad_async_priority,
        io: monad_async_priority,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Ask io_uring to cancel a previously initiated operation. It can take\n! some time for io_uring to cancel an operation, and it may ignore your\n! request."]
    pub fn monad_async_task_io_cancel(
        task: monad_async_task,
        iostatus: *mut monad_async_io_status,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Iterate through completed i/o for this task, reaping each from the\n! completed but not repeated list."]
    pub fn monad_async_task_completed_io(task: monad_async_task) -> *mut monad_async_io_status;
}
extern "C" {
    #[doc = "! \\brief Non-cancellable infinity duration"]
    pub static monad_async_duration_infinite_non_cancelling: u64;
}
#[doc = "! \\brief Cancellable infinity duration"]
pub const monad_async_duration_infinite_cancelling: u64 = 31536000000000000;
extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Suspend execution of a task for a given duration,\n! which can be zero (which equates \"yield\"). If `completed` is not null, if\n! any i/o which the task has initiated completes during the suspension, resume\n! the task setting `completed` to which i/o has just completed."]
    pub fn monad_async_task_suspend_for_duration(
        completed: *mut *mut monad_async_io_status,
        task: monad_async_task,
        ns: u64,
    ) -> monad_c_result;
}
#[doc = "! \\brief A registered i/o buffer"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_task_registered_io_buffer {
    pub index: ::std::os::raw::c_int,
    pub iov: [iovec; 1usize],
}
impl Default for monad_async_task_registered_io_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Flags for claiming a registered i/o buffer"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default)]
pub struct monad_async_task_claim_registered_io_buffer_flags {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl monad_async_task_claim_registered_io_buffer_flags {
    #[inline]
    pub fn fail_dont_suspend(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fail_dont_suspend(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _for_read_ring(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__for_read_ring(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fail_dont_suspend: ::std::os::raw::c_uint,
        _for_read_ring: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fail_dont_suspend: u32 = unsafe { ::std::mem::transmute(fail_dont_suspend) };
            fail_dont_suspend as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let _for_read_ring: u32 = unsafe { ::std::mem::transmute(_for_read_ring) };
            _for_read_ring as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " \\brief CANCELLATION POINT Claim an unused registered **write** buffer for\nfile i/o, suspending if none currently available.\n\nThere are two sizes of registered i/o write buffer, small and large which are\nthe page size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through\nbeing always whole page sizes, DMA using registered i/o buffers has the lowest\npossible overhead.\n\nIt is important to note that these buffers can ONLY be used for write operations\non the write ring. For read operations, it is io_uring which allocates the\nbuffers."]
    pub fn monad_async_task_claim_registered_file_io_write_buffer(
        buffer: *mut monad_async_task_registered_io_buffer,
        task: monad_async_task,
        bytes_requested: usize,
        flags: monad_async_task_claim_registered_io_buffer_flags,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief CANCELLATION POINT Claim an unused registered **write** buffer for\nsocket i/o, suspending if none currently available.\n\nThere are two sizes of registered i/o write buffer, small and large which are\nthe page size of the host platform (e.g. 4Kb and 2Mb if on Intel x64). Through\nbeing always whole page sizes, DMA using registered i/o buffers has the lowest\npossible overhead.\n\nIt is important to note that these buffers can ONLY be used for write operations\non the write ring. For read operations, it is io_uring which allocates the\nbuffers."]
    pub fn monad_async_task_claim_registered_socket_io_write_buffer(
        buffer: *mut monad_async_task_registered_io_buffer,
        task: monad_async_task,
        bytes_requested: usize,
        flags: monad_async_task_claim_registered_io_buffer_flags,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Release a previously claimed registered buffer.\n\nYou must claim write i/o buffers using\n`monad_async_task_claim_registered_file_io_write_buffer()` or\n`monad_async_task_claim_registered_socket_io_write_buffer()`. Read i/o buffers\nare allocated by io_uring, you release them after use using this function."]
    pub fn monad_async_task_release_registered_io_buffer(
        task: monad_async_task,
        buffer_index: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
#[doc = "! \\brief The public attributes of an executor"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_head {
    pub current_task: u64,
    pub tasks_pending_launch: u64,
    pub tasks_running: u64,
    pub tasks_suspended_sqe_exhaustion: u64,
    pub tasks_suspended: u64,
    pub total_ticks_in_run: monad_context_cpu_ticks_count_t,
    pub total_ticks_in_task_launch: monad_context_cpu_ticks_count_t,
    pub total_ticks_in_io_uring: monad_context_cpu_ticks_count_t,
    pub total_ticks_sleeping: monad_context_cpu_ticks_count_t,
    pub total_ticks_in_task_completion: monad_context_cpu_ticks_count_t,
    pub total_io_submitted: u64,
    pub total_io_completed: u64,
    pub registered_buffers: monad_async_executor_head__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_head__bindgen_ty_1 {
    pub total_claimed: usize,
    pub total_released: usize,
    pub ticks_last_claim: monad_context_cpu_ticks_count_t,
    pub ticks_last_release: monad_context_cpu_ticks_count_t,
}
#[doc = "! \\brief Attributes by which to construct an executor"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr {
    pub io_uring_ring: monad_async_executor_attr__bindgen_ty_1,
    pub io_uring_wr_ring: monad_async_executor_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1 {
    #[doc = "! \\brief If this is zero, this executor will be incapable of doing\n! i/o! It also no longer initialises io_uring for this executor."]
    pub entries: ::std::os::raw::c_uint,
    pub params: io_uring_params,
    pub registered_buffers: monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_executor_attr__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! \\brief How many small and large buffers to register."]
    pub small_count: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many small and large buffers to register."]
    pub large_count: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many of each of small pages and of large pages the\n! small and large buffer sizes are."]
    pub small_multiplier: ::std::os::raw::c_uint,
    #[doc = "! \\brief How many of each of small pages and of large pages the\n! small and large buffer sizes are."]
    pub large_multiplier: ::std::os::raw::c_uint,
    #[doc = " \\brief Number of small and large buffers to have io_uring\nallocate during read operations.\n\nio_uring can allocate i/o buffers at the point of successful read\nwhich is obviously much more efficient than userspace allocating\nread i/o buffers prior to initiating the read, which ties up i/o\nbuffers. However, socket i/o doesn't use the write ring, so if all\nbuffers are allocated for read then you would have no buffers for\nwriting to sockets. Therefore you may want some of the buffers\navailable for userspace allocation, and some for kernel allocation\ndepending on use case.\n\nA further complication is that if you enable this facility, if\nio_uring receives i/o and no buffers remain available to it, it\nwill fail the read i/o with a result equivalent to `ENOBUFS`. It\nis 100% on you to free up some buffers and reschedule the read if\nthis occurs.\n\nNote that kernel 6.8 (Ubuntu 24.04) appears to refuse to allocate\nbuffers for file i/o only, a future kernel release may fix this.\nhttps://github.com/axboe/liburing/issues/1214 tracks the feature\nrequest."]
    pub small_kernel_allocated_count: ::std::os::raw::c_uint,
    #[doc = " \\brief Number of small and large buffers to have io_uring\nallocate during read operations.\n\nio_uring can allocate i/o buffers at the point of successful read\nwhich is obviously much more efficient than userspace allocating\nread i/o buffers prior to initiating the read, which ties up i/o\nbuffers. However, socket i/o doesn't use the write ring, so if all\nbuffers are allocated for read then you would have no buffers for\nwriting to sockets. Therefore you may want some of the buffers\navailable for userspace allocation, and some for kernel allocation\ndepending on use case.\n\nA further complication is that if you enable this facility, if\nio_uring receives i/o and no buffers remain available to it, it\nwill fail the read i/o with a result equivalent to `ENOBUFS`. It\nis 100% on you to free up some buffers and reschedule the read if\nthis occurs.\n\nNote that kernel 6.8 (Ubuntu 24.04) appears to refuse to allocate\nbuffers for file i/o only, a future kernel release may fix this.\nhttps://github.com/axboe/liburing/issues/1214 tracks the feature\nrequest."]
    pub large_kernel_allocated_count: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " \\brief EXPENSIVE Creates an executor instance. You must create it on the\nkernel thread where it will be used.\n\nGenerally, one also needs to create context switcher instances for each\nexecutor instance. This is because the context switcher needs to store how\nto resume the executor when a task's execution suspends.\n\nYou can optionally create an io_uring instance for the executor by setting\n`attr->io_uring_ring.entries` to non-zero. This will then be used to dispatch\nwork instead of an internal dispatcher.\n\nYou may additionally optionally create a second io_uring instance called\n\"write ring\" by setting `attr->io_uring_wr_ring.entries` to non-zero. This\nis mandatory if you wish to write to files, otherwise it is not used.\n\nThe reason a special io_uring instance is used for operations which modify\nfiles is because a total sequentially consistent order is applied to all file\nwrite operations. This implements a \"multi-copy atomic\" memory model similar\nto that used by ARM microprocessors. This is a weak memory model, but one\nsufficient to prevent:\n\n1. Write amplification on the device caused by multiple concurrent writes.\n\n2. Writes appearing to readers not in the order of write submission.\n\nThe most efficient way of implementing this weak memory model is a specially\nconfigured io_uring instance, so this is why we have that.\n\nDo NOT use the \"write ring\" for writes to sockets, it will severely impact\nperformance!"]
    pub fn monad_async_executor_create(
        ex: *mut monad_async_executor,
        attr: *mut monad_async_executor_attr,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys an executor instance."]
    pub fn monad_async_executor_destroy(ex: monad_async_executor) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Processes no more than `max_items` work items, returning the number\nof items processed. A null `timeout` means wait forever, and a zero timeout will\npoll without blocking.\n\nNote that this function is particularly prone to early return i.e. partly\nor entirely ignoring timeout. Causes can include being woken externally by\n`monad_async_executor_wake()`, there being write i/o pending (as then two\nrings need to be checked), and the usual spurious early timeouts from Linux.\nIf you do complex processing around calling this function, it may be wise\nto only do that processing if the value returned is not zero."]
    pub fn monad_async_executor_run(
        ex: monad_async_executor,
        max_items: usize,
        timeout: *const timespec,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping executor to wake. Can be called from any\n! kernel thread. `cause_run_to_return` causes `monad_async_executor_run()` to\n! return the result given, otherwise the internal sleep wakes, executor state\n! is examined for new work and the sleep reestablished WHICH MAY NOT CAUSE RUN\n! TO RETURN."]
    pub fn monad_async_executor_wake(
        ex: monad_async_executor,
        cause_run_to_return: *const monad_c_result,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief If new i/o submitted since the last run exceeds\n`max_items_in_submission_queue`, invoke io_uring submit now. If submission now\noccurs, a positive successful result is returned, otherwise zero."]
    pub fn monad_async_executor_submit(
        ex: monad_async_executor,
        max_items_in_nonwrite_submission_queue: usize,
        max_items_in_write_submission_queue: usize,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Return a pointer (as `intptr_t`) to a null terminated string\ndescribing the configuration of this executor. This lets you see what io_uring\nfeatures were detected, as well as versions and other config.\n\n\\warning You need to call `free()` on the pointer when you are done with it."]
    pub fn monad_async_executor_config_string(ex: monad_async_executor) -> monad_c_result;
}
#[doc = "! \\brief An offset into a file"]
pub type monad_async_file_offset = u64;
#[doc = "! \\brief The public attributes of an open file"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_file_head {
    pub executor: *mut monad_async_executor_head,
}
impl Default for monad_async_file_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open file"]
pub type monad_async_file = *mut monad_async_file_head;
extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nfile has been opened. See `man open2` to explain parameters.\n\nThis is a relatively expensive operation as it may do up to two mallocs and\nseveral syscalls per call."]
    pub fn monad_async_task_file_create(
        file: *mut monad_async_file,
        task: monad_async_task,
        base: monad_async_file,
        subpath: *const ::std::os::raw::c_char,
        how: *mut open_how,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nuserspace file descriptor has been registered with io_uring and a file instance\nrepresenting it returned.\n\nThis function is provided purely for bridging this to legacy code -- wherever\npossible you should use the native file and socket creation functions as\nthese completely bypass userspace and don't create any of the problems POSIX\nfile descriptors do."]
    pub fn monad_async_task_file_create_from_existing_fd(
        file: *mut monad_async_file,
        task: monad_async_task,
        fd: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the file has been closed"]
    pub fn monad_async_task_file_destroy(
        task: monad_async_task,
        file: monad_async_file,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief CANCELLATION POINT Suspend execution of the task until the file's\n! valid extents have been modified as per the `fallocate` call, see `man\n! fallocate` for more."]
    pub fn monad_async_task_file_fallocate(
        task: monad_async_task,
        file: monad_async_file,
        mode: ::std::os::raw::c_int,
        offset: monad_async_file_offset,
        len: monad_async_file_offset,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Initiate a ring buffer read from an open file using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man readv2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nUpon completion, `tofill->iovecs[0]` will be the buffer filled with up to\n`max_bytes` (though it can be less). When you are done with the buffer, release\nit back to io_uring using `monad_async_task_release_registered_io_buffer()`.\nLack of i/o buffers will cause suspension of the calling task until i/o\nbuffers are released.\n\n`max_bytes` chooses whether to use large or small page sized buffers and the\nactual bytes read does not affect the size of buffer chosen."]
    pub fn monad_async_task_file_read(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        tofill: *mut monad_async_task_registered_io_buffer,
        max_bytes: usize,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a scatter read from an open file using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man readv2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of iovecs have lifetime until\nthe read completes. The only exception here is if `nr_vecs` is one."]
    pub fn monad_async_task_file_readv(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a write to an open file using `iostatus` as the identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man writev2` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of iovecs have lifetime until\nthe writes completes. The only exception here is if `nr_vecs` is one."]
    pub fn monad_async_task_file_write(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        buffer_index: ::std::os::raw::c_int,
        iovecs: *const iovec,
        nr_vecs: ::std::os::raw::c_uint,
        offset: monad_async_file_offset,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "! \\brief Initiate a flush of dirty file extents using `iostatus` as the\n! identifier. Returns immediately unless there are no free io_uring submission\n! entries. See `man sync_file_range` to explain parameters. The i/o priority\n! used will be that from the task's current i/o priority setting. This is the\n! right call to use to encourage the kernel to flush a region of data now, it\n! is the wrong call to ensure write durability as it neither flushes metadata\n! nor tells the storage device to flush."]
    pub fn monad_async_task_file_range_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
        offset: monad_async_file_offset,
        bytes: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "! \\brief Initiate a durable sync of an open file using `iostatus` as\n! the identifier. Returns immediately unless there are no free io_uring\n! submission entries. The i/o priority used will be that from the task's\n! current i/o priority setting. This is the right call to use to ensure\n! written data is durably placed onto non-volatile storage.\n!\n! Note that this operation generally takes milliseconds to complete."]
    pub fn monad_async_task_file_durable_sync(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        file: monad_async_file,
    );
}
#[doc = "! \\brief The public attributes of an open socket"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_socket_head {
    pub addr: sockaddr,
    pub addr_len: socklen_t,
    pub executor: *mut monad_async_executor_head,
}
impl Default for monad_async_socket_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of an open socket"]
pub type monad_async_socket = *mut monad_async_socket_head;
extern "C" {
    #[doc = " \\brief EXPENSIVE Create a socket. See `man socket` to explain parameters.\n\nAt least one malloc is performed, and possibly more."]
    pub fn monad_async_task_socket_create(
        sock: *mut monad_async_socket,
        task: monad_async_task,
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief EXPENSIVE, CANCELLATION POINT Suspend execution of the task until the\nuserspace file descriptor has been registered with io_uring and a socket\ninstance representing it returned.\n\nThis function is provided purely for bridging this to legacy code -- wherever\npossible you should use the native file and socket creation functions as\nthese completely bypass userspace and don't create any of the problems POSIX\nfile descriptors do."]
    pub fn monad_async_task_socket_create_from_existing_fd(
        sock: *mut monad_async_socket,
        task: monad_async_task,
        fd: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Suspend execution of the task until the socket has been closed"]
    pub fn monad_async_task_socket_destroy(
        task: monad_async_task,
        sock: monad_async_socket,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief EXPENSIVE Bind a socket to an interface and port.\n\nThis is done by blocking syscall, as io_uring is currently incapable of doing\nlistening socket setup by itself."]
    pub fn monad_async_task_socket_bind(
        sock: monad_async_socket,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief EXPENSIVE Make a bound socket available for incoming connections.\n\nThis is done by blocking syscall, as io_uring is currently incapable of doing\nlistening socket setup by itself."]
    pub fn monad_async_task_socket_listen(
        sock: monad_async_socket,
        backlog: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief CANCELLATION POINT Transfers the socket to io_uring, which may\nrequire suspending the task.\n\nAs io_uring is currently incapable of doing listening socket setup by itself,\nthere is an explicit step for transferring the configured socket to io_uring\nas it is an expensive operation.\n\nNewer Linux kernels have an io_uring capable of connecting socket setup and\ncreation entirely within io_uring. If your kernel is so capable, that is used,\nelse blocking syscalls are used and the socket transferred into io_uring.\n\nWhen this call returns, all syscall-created resources are released and io_uring\nexclusively manages the socket."]
    pub fn monad_async_task_socket_transfer_to_uring(
        task: monad_async_task,
        sock: monad_async_socket,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief CANCELLATION POINT Suspend execution of the task if there is no\npending connection on the socket until there is a new connection. See `man\naccept4` to explain parameters.\n\nNote that if `SOCK_CLOEXEC` is set in the flags, io_uring will fail the request\n(this is non-obvious, cost me half a day of debugging, so I document it here)"]
    pub fn monad_async_task_socket_accept(
        connected_sock: *mut monad_async_socket,
        task: monad_async_task,
        listening_sock: monad_async_socket,
        flags: ::std::os::raw::c_int,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = " \\brief Initiate the connection of an open socket using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man connect` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting."]
    pub fn monad_async_task_socket_connect(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        addr: *const sockaddr,
        addrlen: socklen_t,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a shutdown of an open socket using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man shutdown` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting."]
    pub fn monad_async_task_socket_shutdown(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a ring buffer read from an open socket using `iostatus` as\nthe identifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man recvmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\nIf the executor was so configured, this API has io_uring allocate the buffer\nwhich is more efficient than the application saying which buffer to fill. Upon\ncompletion, `tofill->iovecs[0]` will be the buffer filled with up to `max_bytes`\n(though it can be less). When you are done with the buffer, release it back to\nio_uring using `monad_async_task_release_registered_io_buffer()`.\nIf this operation gets a result failure comparing equivalent to `ENOBUFS`,\nthen io_uring ran out of buffers to allocate. You should increase\n`small_kernel_allocated_count` et al in `struct monad_async_executor_attr`.\n\nIf the executor was not configured with `small_kernel_allocated_count` et al,\nthen lack of i/o buffers will cause suspension of the calling task until i/o\nbuffers are released. You must still release buffers filled back to\nio_uring using `monad_async_task_release_registered_io_buffer()`\n\n`max_bytes` chooses whether to use large or small page sized buffers and the\nactual bytes read does not affect the size of buffer chosen.\n\n\\warning io_uring **requires** that the contents of `tofill` and everything it\npoints at have lifetime until the read completes."]
    pub fn monad_async_task_socket_receive(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        tofill: *mut monad_async_task_registered_io_buffer,
        max_bytes: usize,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a scatter read from an open socket using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man recvmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of `msg` and everything it\npoints at have lifetime until the read completes."]
    pub fn monad_async_task_socket_receivev(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        msg: *mut msghdr,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Initiate a write to an open socket using `iostatus` as the\nidentifier.\n\nReturns immediately unless there are no free io_uring submission entries.\nSee `man sendmsg` to explain parameters. The i/o priority used will be that\nfrom the task's current i/o priority setting.\n\n\\warning io_uring **requires** that the contents of `msg` and everything it\npoints at have lifetime until the write completes."]
    pub fn monad_async_task_socket_send(
        iostatus: *mut monad_async_io_status,
        task: monad_async_task,
        sock: monad_async_socket,
        buffer_index: ::std::os::raw::c_int,
        msg: *const msghdr,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "! \\brief Returns a temporary directory in which `O_DIRECT` files definitely\n! work"]
    pub fn monad_async_working_temporary_directory() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! \\brief Creates a temporary file, writing the path created into the buffer.\n! You will need to unlink this after yourself and close the file descriptor it\n! returns."]
    pub fn monad_async_make_temporary_file(
        buffer: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! \\brief Creates already deleted file so no need to clean it up\n! after. You will need to close the file descriptor it returns."]
    pub fn monad_async_make_temporary_inode() -> ::std::os::raw::c_int;
}
pub const monad_async_memory_accounting_kind_monad_async_memory_accounting_kind_unknown:
    monad_async_memory_accounting_kind = 0;
#[doc = "! \\brief This Linux has been configured for strict memory accounting"]
pub const monad_async_memory_accounting_kind_monad_async_memory_accounting_kind_commit_charge:
    monad_async_memory_accounting_kind = 1;
#[doc = "! \\brief This Linux has been configured for over commit memory accounting"]
pub const monad_async_memory_accounting_kind_monad_async_memory_accounting_kind_over_commit:
    monad_async_memory_accounting_kind = 2;
#[doc = "! \\brief How this Linux accounts for memory"]
pub type monad_async_memory_accounting_kind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\brief Return how this Linux accounts for memory"]
    pub fn monad_async_memory_accounting() -> monad_async_memory_accounting_kind;
}
extern "C" {
    #[doc = " \\brief Return the current monotonic CPU tick count.\n\n`rel` affects how the CPU tick count is measured, and it is the same as for\natomics:\n\n- `memory_order_relaxed`: Read the count in the most efficient way possible,\nwhich may be plus or minus two hundred instructions from accurate (i.e. plus\nor minus up to 100 nanoseconds, but usually a lot less). Usually costs about\n25-45 cycles, but other instructions can execute concurrently.\n- `memory_order_acquire`: Do not execute any instructions after reading the\ncount until the count has been read, but instructions preceding reading the\ncount may be executed after reading the count.\n- `memory_order_release`: Do not execute instructions preceding reading the\ncount after reading the count, but instructions after reading the count may be\nexecuted before reading the count.\n- `memory_order_acq_rel` and `memory_order_seq_cst`: Instructions preceding\nreading the count will be completed in full before reading the count, and\ninstructions after reading the count will not begin executing until the count\nhas been read. This is perfectly accurate, but comes with a substantial\nperformance impact as it stalls the CPU and flushes its pipelines. 100-120\ncycles would be expected as a minimum, often more as it also disrupts prefetch\nand branch prediction."]
    pub fn monad_async_get_ticks_count(rel: memory_order) -> monad_context_cpu_ticks_count_t;
}
extern "C" {
    #[doc = "! \\brief Return how many CPU ticks per second there are. The first caller\n! of this will need to wait up to one second for the number to be calculated."]
    pub fn monad_async_ticks_per_second() -> monad_context_cpu_ticks_count_t;
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head {
    pub executors: monad_async_work_dispatcher_head__bindgen_ty_1,
    pub tasks_awaiting_dispatch: u64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_head__bindgen_ty_1 {
    pub working: u32,
    pub idle: u32,
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher = *mut monad_async_work_dispatcher_head;
#[doc = "! \\brief The public attributes of a work dispatcher"]
#[repr(C)]
#[derive(Debug)]
pub struct monad_async_work_dispatcher_executor_head {
    pub derived: *mut monad_async_executor_head,
    pub dispatcher: *mut monad_async_work_dispatcher_head,
    pub is_working: u8,
    pub is_idle: u8,
}
impl Default for monad_async_work_dispatcher_executor_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The public attributes of a work dispatcher"]
pub type monad_async_work_dispatcher_executor = *mut monad_async_work_dispatcher_executor_head;
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_attr {
    #[doc = "! Dispatcher executors should spin the CPU for this many milliseconds\n! before sleeping"]
    pub spin_before_sleep_ms: u32,
}
#[doc = "! \\brief Attributes by which to construct a work dispatcher"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct monad_async_work_dispatcher_executor_attr {
    pub derived: monad_async_executor_attr,
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_create(
        dp: *mut monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_attr,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher instance."]
    pub fn monad_async_work_dispatcher_destroy(dp: monad_async_work_dispatcher) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Creates a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_create(
        ex: *mut monad_async_work_dispatcher_executor,
        dp: monad_async_work_dispatcher,
        attr: *mut monad_async_work_dispatcher_executor_attr,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief EXPENSIVE Destroys a work dispatcher executor instance."]
    pub fn monad_async_work_dispatcher_executor_destroy(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief Calls `monad_async_executor_run()` for the calling kernel thread,\n! attaching tasks recently submitted to kernel threads in the pool with spare\n! capacity as per the work dispatcher's configured policy. Returns the number\n! of work items executed, or -1 when time to exit."]
    pub fn monad_async_work_dispatcher_executor_run(
        ex: monad_async_work_dispatcher_executor,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Causes a sleeping work dispatcher executor to wake. Same\n! as `monad_async_executor_wake()`, but for work dispatcher executors."]
    pub fn monad_async_work_dispatcher_executor_wake(
        ex: monad_async_work_dispatcher_executor,
        cause_run_to_return: *const monad_c_result,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Submits one or more tasks to be executed by the first\n! available executor within the work dispatcher pool. Higher priority tasks\n! are executed before lower priority tasks."]
    pub fn monad_async_work_dispatcher_submit(
        dp: monad_async_work_dispatcher,
        tasks: *mut monad_async_task,
        count: usize,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Wait until all work has been dispatched or executed."]
    pub fn monad_async_work_dispatcher_wait(
        dp: monad_async_work_dispatcher,
        max_undispatched: usize,
        max_unexecuted: usize,
        timeout: *mut timespec,
    ) -> monad_c_result;
}
extern "C" {
    #[doc = "! \\brief THREADSAFE Tells executors to quit, preferring idle executors first,\n! until no more than `max_executors` remains."]
    pub fn monad_async_work_dispatcher_quit(
        dp: monad_async_work_dispatcher,
        max_executors: usize,
        timeout: *mut timespec,
    ) -> monad_c_result;
}
