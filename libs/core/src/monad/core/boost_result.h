/* C interface for result
(C) 2017-2024 Niall Douglas <http://www.nedproductions.biz/> (6 commits)
File Created: Aug 2017


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_OUTCOME_EXPERIMENTAL_RESULT_H
#define BOOST_OUTCOME_EXPERIMENTAL_RESULT_H

#include <assert.h>
#include <stddef.h> // for size_t
#include <stdint.h> // for intptr_t

/* Try operation macros
(C) 2017-2024 Niall Douglas <http://www.nedproductions.biz/> (20 commits)
File Created: July 2017


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_OUTCOME_TRY_H
    #define BOOST_OUTCOME_TRY_H
    #ifndef BOOST_OUTCOME_TRY_CALL_OVERLOAD

        #if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 8
            #pragma GCC diagnostic push
            #pragma GCC diagnostic ignored "-Wparentheses"
        #endif

        #define BOOST_OUTCOME_TRY_GLUE2(x, y) x##y
        #define BOOST_OUTCOME_TRY_GLUE(x, y) BOOST_OUTCOME_TRY_GLUE2(x, y)
        #define BOOST_OUTCOME_TRY_UNIQUE_NAME                                  \
            BOOST_OUTCOME_TRY_GLUE(                                            \
                _outcome_try_unique_name_temporary, __COUNTER__)

        #define BOOST_OUTCOME_TRY_RETURN_ARG_COUNT(                            \
            _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, count, ...)                \
            count
        #define BOOST_OUTCOME_TRY_EXPAND_ARGS(args)                            \
            BOOST_OUTCOME_TRY_RETURN_ARG_COUNT args
        #define BOOST_OUTCOME_TRY_COUNT_ARGS_MAX8(...)                         \
            BOOST_OUTCOME_TRY_EXPAND_ARGS(                                     \
                (__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1, 0))
        #define BOOST_OUTCOME_TRY_OVERLOAD_MACRO2(name, count) name##count
        #define BOOST_OUTCOME_TRY_OVERLOAD_MACRO1(name, count)                 \
            BOOST_OUTCOME_TRY_OVERLOAD_MACRO2(name, count)
        #define BOOST_OUTCOME_TRY_OVERLOAD_MACRO(name, count)                  \
            BOOST_OUTCOME_TRY_OVERLOAD_MACRO1(name, count)
        #define BOOST_OUTCOME_TRY_OVERLOAD_GLUE(x, y) x y
        #define BOOST_OUTCOME_TRY_CALL_OVERLOAD(name, ...)                     \
            BOOST_OUTCOME_TRY_OVERLOAD_GLUE(                                   \
                BOOST_OUTCOME_TRY_OVERLOAD_MACRO(                              \
                    name, BOOST_OUTCOME_TRY_COUNT_ARGS_MAX8(__VA_ARGS__)),     \
                (__VA_ARGS__))

        #define _OUTCOME_TRY_RETURN_ARG_COUNT(                                 \
            _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, count, ...)                \
            count
        #define _OUTCOME_TRY_EXPAND_ARGS(args)                                 \
            _OUTCOME_TRY_RETURN_ARG_COUNT args
        #define _OUTCOME_TRY_COUNT_ARGS_MAX8(...)                              \
            _OUTCOME_TRY_EXPAND_ARGS((__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1, 0))
        #define _OUTCOME_TRY_OVERLOAD_MACRO2(name, count) name##count
        #define _OUTCOME_TRY_OVERLOAD_MACRO1(name, count)                      \
            _OUTCOME_TRY_OVERLOAD_MACRO2(name, count)
        #define _OUTCOME_TRY_OVERLOAD_MACRO(name, count)                       \
            _OUTCOME_TRY_OVERLOAD_MACRO1(name, count)
        #define _OUTCOME_TRY_OVERLOAD_GLUE(x, y) x y
        #define _OUTCOME_TRY_CALL_OVERLOAD(name, ...)                          \
            _OUTCOME_TRY_OVERLOAD_GLUE(                                        \
                _OUTCOME_TRY_OVERLOAD_MACRO(                                   \
                    name, _OUTCOME_TRY_COUNT_ARGS_MAX8(__VA_ARGS__)),          \
                (__VA_ARGS__))

        #if !defined(BOOST_OUTCOME_TRY_LIKELY_IF) &&                           \
            defined(__has_cpp_attribute)
            #if __has_cpp_attribute(likely)
                #define BOOST_OUTCOME_TRY_LIKELY_IF(...)                       \
                    if (__VA_ARGS__) [[likely]]
            #endif
        #endif
        #ifndef BOOST_OUTCOME_TRY_LIKELY_IF
            #if defined(__clang__) || defined(__GNUC__)
                #define BOOST_OUTCOME_TRY_LIKELY_IF(...)                       \
                    if (__builtin_expect(!!(__VA_ARGS__), 1))
            #else
                #define BOOST_OUTCOME_TRY_LIKELY_IF(...) if (__VA_ARGS__)
            #endif
        #endif

        #ifdef __cplusplus
            #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_AUTO(...) auto
        #else
            #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_AUTO(...)               \
                __typeof__(__VA_ARGS__)
        #endif

        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_UNPACK(...) __VA_ARGS__
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE3(unique, ...)        \
            BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_AUTO(__VA_ARGS__)               \
            unique = (__VA_ARGS__)
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE2(x) x
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE(unique, x, ...)      \
            BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE2(                        \
                BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE3(                    \
                    unique, __VA_ARGS__))
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED3(                 \
            unique, x, y, ...)                                                 \
            x unique = (__VA_ARGS__)
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED2(x) x
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED(unique, ...)      \
            BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED2(                     \
                BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED3(                 \
                    unique, __VA_ARGS__))
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE1(...)                       \
            BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_DEDUCE
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE2(...)                       \
            BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_SPECIFIED
        #define BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE(unique, spec, ...)          \
            _OUTCOME_TRY_CALL_OVERLOAD(                                        \
                BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE,                            \
                BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_UNPACK spec)                \
            (unique,                                                           \
             BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_UNPACK spec,                   \
             __VA_ARGS__)

        #define BOOST_OUTCOME_TRY2_VAR_SECOND2(x, var) var
        #define BOOST_OUTCOME_TRY2_VAR_SECOND3(x, y, ...) x y
        #define BOOST_OUTCOME_TRY2_VAR(spec)                                   \
            _OUTCOME_TRY_CALL_OVERLOAD(                                        \
                BOOST_OUTCOME_TRY2_VAR_SECOND,                                 \
                BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE_UNPACK spec,                \
                spec)

        #if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 8
            #pragma GCC diagnostic pop
        #endif

    #endif
#endif

#ifndef BOOST_OUTCOME_C_WEAK
    #ifdef _MSC_VER
        #define BOOST_OUTCOME_C_WEAK inline
    #else
        #define BOOST_OUTCOME_C_WEAK __attribute__((weak))
    #endif
#endif

#ifndef BOOST_OUTCOME_C_MSVC_FORCE_EMIT
    #ifdef _MSC_VER
        #ifdef __cplusplus
            #define BOOST_OUTCOME_C_MSVC_FORCE_EMIT(x)                         \
                extern "C" __declspec(selectany) void *x##_emit = x;
        #else
            #define BOOST_OUTCOME_C_MSVC_FORCE_EMIT(x)                         \
                extern __declspec(selectany) void *x##_emit = x;
        #endif
    #else
        #define BOOST_OUTCOME_C_MSVC_FORCE_EMIT(x)
    #endif
#endif

#ifndef BOOST_OUTCOME_C_NODISCARD
    #if __STDC_VERSION__ >= 202000L || __cplusplus >= 201700L
        #define BOOST_OUTCOME_C_NODISCARD [[nodiscard]]
        #ifdef __cplusplus
            #define BOOST_OUTCOME_C_NODISCARD_EXTERN_C extern "C" [[nodiscard]]
        #else
            #define BOOST_OUTCOME_C_NODISCARD_EXTERN_C [[nodiscard]] extern
        #endif
    #elif defined(__GNUC__) || defined(__clang__)
        #define BOOST_OUTCOME_C_NODISCARD __attribute__((warn_unused_result))
        #ifdef __cplusplus
            #define BOOST_OUTCOME_C_NODISCARD_EXTERN_C                         \
                extern "C" __attribute__((warn_unused_result))
        #else
            #define BOOST_OUTCOME_C_NODISCARD_EXTERN_C                         \
                extern __attribute__((warn_unused_result))
        #endif
    #else
        #define BOOST_OUTCOME_C_NODISCARD
        #define BOOST_OUTCOME_C_NODISCARD_EXTERN_C extern
    #endif
#endif

#ifndef BOOST_OUTCOME_C_INLINE
    #if __STDC_VERSION__ >= 199900L || __cplusplus > 0
        #define BOOST_OUTCOME_C_INLINE inline
    #elif defined(__GNUC__) || defined(__clang__)
        #define BOOST_OUTCOME_C_INLINE __inline
    #endif
#endif

/* Inline GDB pretty printer for result
(C) 2024 Niall Douglas <http://www.nedproductions.biz/> (6 commits)
File Created: Jun 2024


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_OUTCOME_INLINE_GDB_PRETTY_PRINTER_H
    #define BOOST_OUTCOME_INLINE_GDB_PRETTY_PRINTER_H

    #ifndef BOOST_OUTCOME_DISABLE_INLINE_GDB_PRETTY_PRINTERS
        #if defined(__ELF__)
            #ifdef __clang__
                #pragma clang diagnostic push
                #pragma clang diagnostic ignored "-Woverlength-strings"
            #endif
__asm__(
    ".pushsection \".debug_gdb_scripts\", \"MS\",@progbits,1\n"
    ".byte 4 /* Python Text */\n"
    ".ascii \"gdb.inlined-script.outcome\\n\"\n"
    ".ascii \"import gdb.printing\\n\"\n"
    ".ascii \"import os\\n\"\n"

    ".ascii \"def synthesise_gdb_value_from_string(s):\\n\"\n"
    ".ascii \"    '''For when you want to return a synthetic string from "
    "children()'''\\n\"\n"
    ".ascii \"    return gdb.Value(s + "
    "'\\\\0').cast(gdb.lookup_type('char').pointer())\\n\"\n"

    ".ascii \"class OutcomeBasicOutcomePrinter(object):\\n\"\n"
    ".ascii \"    '''Print an outcome::basic_outcome<T> and "
    "outcome::basic_result<T>'''\\n\"\n"

    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"

    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 1 == "
    "1:\\n\"\n"
    ".ascii \"            yield ('value', self.val['_state']['_value'])\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 2 == "
    "2:\\n\"\n"
    ".ascii \"            yield ('error', self.val['_state']['_error'])\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 4 == "
    "4:\\n\"\n"
    ".ascii \"            yield ('exception', self.val['_ptr'])\\n\"\n"

    ".ascii \"    def display_hint(self):\\n\"\n"
    ".ascii \"        return None\\n\"\n"

    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 54 == "
    "54:\\n\"\n"
    ".ascii \"            return 'errored (errno, moved from) + "
    "exceptioned'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 50 == "
    "50:\\n\"\n"
    ".ascii \"            return 'errored (errno, moved from)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 38 == "
    "38:\\n\"\n"
    ".ascii \"            return 'errored + exceptioned (moved from)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 36 == "
    "36:\\n\"\n"
    ".ascii \"            return 'exceptioned (moved from)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 35 == "
    "35:\\n\"\n"
    ".ascii \"            return 'errored (moved from)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 33 == "
    "33:\\n\"\n"
    ".ascii \"            return 'valued (moved from)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 22 == "
    "22:\\n\"\n"
    ".ascii \"            return 'errored (errno) + exceptioned'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 18 == "
    "18:\\n\"\n"
    ".ascii \"            return 'errored (errno)'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 6 == "
    "6:\\n\"\n"
    ".ascii \"            return 'errored + exceptioned'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 4 == "
    "4:\\n\"\n"
    ".ascii \"            return 'exceptioned'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 2 == "
    "2:\\n\"\n"
    ".ascii \"            return 'errored'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 1 == "
    "1:\\n\"\n"
    ".ascii \"            return 'valued'\\n\"\n"
    ".ascii \"        if self.val['_state']['_status']['status_value'] & 0xff "
    "== 0:\\n\"\n"
    ".ascii \"            return 'empty'\\n\"\n"

    ".ascii \"class OutcomeCResultStatusPrinter(object):\\n\"\n"
    ".ascii \"    '''Print a C result'''\\n\"\n"

    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"

    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        if self.val['flags'] & 1 == 1:\\n\"\n"
    ".ascii \"            yield ('value', self.val['value'])\\n\"\n"
    ".ascii \"        if self.val['flags'] & 2 == 2:\\n\"\n"
    ".ascii \"            yield ('error', self.val['error'])\\n\"\n"

    ".ascii \"    def display_hint(self):\\n\"\n"
    ".ascii \"        return None\\n\"\n"

    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        if self.val['flags'] & 50 == 50:\\n\"\n"
    ".ascii \"            return 'errored (errno, moved from)'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 35 == 35:\\n\"\n"
    ".ascii \"            return 'errored (moved from)'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 33 == 33:\\n\"\n"
    ".ascii \"            return 'valued (moved from)'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 18 == 18:\\n\"\n"
    ".ascii \"            return 'errored (errno)'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 2 == 2:\\n\"\n"
    ".ascii \"            return 'errored'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 1 == 1:\\n\"\n"
    ".ascii \"            return 'valued'\\n\"\n"
    ".ascii \"        if self.val['flags'] & 0xff == 0:\\n\"\n"
    ".ascii \"            return 'empty'\\n\"\n"

    ".ascii \"class OutcomeCStatusCodePrinter(object):\\n\"\n"
    ".ascii \"    '''Print a C status code'''\\n\"\n"

    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"

    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        yield ('domain', self.val['domain'])\\n\"\n"
    ".ascii \"        yield ('value', self.val['value'])\\n\"\n"

    ".ascii \"    def display_hint(self):\\n\"\n"
    ".ascii \"        return None\\n\"\n"

    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        s = str(self.val['domain'])\\n\"\n"
    ".ascii \"        if 'posix_code_domain' in s or 'generic_code_domain' in "
    "s:\\n\"\n"
    ".ascii \"            return str(self.val['value']) + ' (' + "
    "os.strerror(int(self.val['value'])) + ')'\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            return self.val['value']\\n\"\n"

    ".ascii \"def build_pretty_printer():\\n\"\n"
    ".ascii \"    pp = "
    "gdb.printing.RegexpCollectionPrettyPrinter('outcome_v2')\\n\"\n"
    ".ascii \"    pp.add_printer('outcome_v2::basic_result', "
    "'^(boost::)?outcome_v2[_0-9a-f]*::basic_result<.*>$', "
    "OutcomeBasicOutcomePrinter)\\n\"\n"
    ".ascii \"    pp.add_printer('outcome_v2::basic_outcome', "
    "'^(boost::)?outcome_v2[_0-9a-f]*::basic_outcome<.*>$', "
    "OutcomeBasicOutcomePrinter)\\n\"\n"
    ".ascii \"    pp.add_printer('cxx_result_status_code_*', "
    "'^cxx_result_status_code_.*$', OutcomeCResultStatusPrinter)\\n\"\n"
    ".ascii \"    pp.add_printer('cxx_status_code_*', '^cxx_status_code_.*$', "
    "OutcomeCStatusCodePrinter)\\n\"\n"
    ".ascii \"    return pp\\n\"\n"

    ".ascii \"def register_printers(obj = None):\\n\"\n"
    ".ascii \"    gdb.printing.register_pretty_printer(obj, "
    "build_pretty_printer(), replace = True)\\n\"\n"

    ".ascii \"register_printers(gdb.current_objfile())\\n\"\n"

    ".byte 0\n"
    ".popsection\n");
            #ifdef __clang__
                #pragma clang diagnostic pop
            #endif
        #endif
    #endif

#endif

#ifdef __cplusplus
extern "C"
{
#endif

#define BOOST_OUTCOME_C_DECLARE_RESULT(ident, R, S)                            \
    struct cxx_result_##ident                                                  \
    {                                                                          \
        union                                                                  \
        {                                                                      \
            R value;                                                           \
            S error;                                                           \
        };                                                                     \
        unsigned flags;                                                        \
    }

#define BOOST_OUTCOME_C_RESULT(ident) struct cxx_result_##ident

#define BOOST_OUTCOME_C_RESULT_HAS_VALUE(r) (((r).flags & 1U) == 1U)

#define BOOST_OUTCOME_C_RESULT_HAS_ERROR(r) (((r).flags & 2U) == 2U)

#define BOOST_OUTCOME_C_RESULT_ERROR_IS_ERRNO(r)                               \
    (((r).flags & (1U << 4U)) == (1U << 4U))

/***************************** <system_error2> support
 * ******************************/

#define BOOST_OUTCOME_C_DECLARE_STATUS_CODE(ident, value_type)                 \
    struct cxx_status_code_##ident                                             \
    {                                                                          \
        void *domain;                                                          \
        value_type value;                                                      \
    };

#define BOOST_OUTCOME_C_STATUS_CODE(ident) struct cxx_status_code_##ident

extern BOOST_OUTCOME_C_WEAK void outcome_make_result_status_code_success(
    void *out, size_t bytes, size_t offset, void const *toset,
    size_t tosetbytes);
extern BOOST_OUTCOME_C_WEAK void outcome_make_result_status_code_failure_posix(
    void *out, size_t bytes, size_t offset, int errcode);
extern BOOST_OUTCOME_C_WEAK void outcome_make_result_status_code_failure_system(
    void *out, size_t bytes, size_t offset, intptr_t errcode);
extern int outcome_status_code_equal(void const *a, void const *b);
extern int outcome_status_code_equal_generic(void const *a, int errcode);
extern char const *outcome_status_code_message(void const *a);

#ifdef __cplusplus
    #define BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE_CXX(ident, R, S)        \
        static_assert(                                                         \
            std::is_trivially_copyable<R>::value ||                            \
                BOOST_OUTCOME_V2_NAMESPACE::trait::is_move_bitcopying<         \
                    R>::value,                                                 \
            "R must be trivially copyable or move bitcopying to be used in a " \
            "C Result");                                                       \
        static_assert(                                                         \
            std::is_trivially_copyable<S>::value ||                            \
                BOOST_OUTCOME_V2_NAMESPACE::trait::is_move_bitcopying<         \
                    S>::value,                                                 \
            "S must be trivially copyable or move bitcopying to be used in a " \
            "C Result");                                                       \
        inline BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<R>      \
        to_result(const cxx_result_status_code_##ident &v)                     \
        {                                                                      \
            union type_punner_t                                                \
            {                                                                  \
                cxx_result_status_code_##ident c;                              \
                BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<R>     \
                    cpp;                                                       \
                                                                               \
                type_punner_t()                                                \
                    : c{}                                                      \
                {                                                              \
                }                                                              \
                ~type_punner_t() {}                                            \
            } pun;                                                             \
                                                                               \
            pun.c = v;                                                         \
            return std::move(pun.cpp);                                         \
        }                                                                      \
        BOOST_OUTCOME_C_NODISCARD inline cxx_result_status_code_##ident        \
            to_##ident(                                                        \
                BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<R> v)  \
        {                                                                      \
            union type_punner_t                                                \
            {                                                                  \
                BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<R>     \
                    cpp;                                                       \
                cxx_result_status_code_##ident c;                              \
                                                                               \
                type_punner_t(                                                 \
                    BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<R> \
                        v)                                                     \
                    : cpp(std::move(v))                                        \
                {                                                              \
                }                                                              \
                ~type_punner_t() {}                                            \
            } pun{std::move(v)};                                               \
                                                                               \
            return pun.c;                                                      \
        }
#else
    #define BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE_CXX(ident, R, S)
#endif

#define BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE(ident, R, S)                \
    struct cxx_result_status_code_##ident                                      \
    {                                                                          \
        R value;                                                               \
        unsigned flags;                                                        \
        S error;                                                               \
    };                                                                         \
    BOOST_OUTCOME_C_NODISCARD static BOOST_OUTCOME_C_INLINE struct             \
        cxx_result_status_code_##ident outcome_make_result_##ident##_success(  \
            R value)                                                           \
    { /* We special case this so it inlines efficiently */                     \
        struct cxx_result_status_code_##ident ret;                             \
        ret.value = value;                                                     \
        ret.flags = 1 /* have_value */;                                        \
        return ret;                                                            \
    }                                                                          \
    BOOST_OUTCOME_C_NODISCARD_EXTERN_C                                         \
    BOOST_OUTCOME_C_WEAK struct cxx_result_status_code_##ident                 \
        outcome_make_result_##ident##_failure_posix(int errcode)               \
    {                                                                          \
        struct cxx_result_status_code_##ident ret;                             \
        assert(                                                                \
            outcome_make_result_status_code_failure_posix); /* If this fails,  \
                                                               you need to     \
                                                               compile this    \
                                                               file at least   \
                                                               once in C++. */ \
        outcome_make_result_status_code_failure_posix(                         \
            (void *)&ret,                                                      \
            sizeof(ret),                                                       \
            offsetof(struct cxx_result_status_code_##ident, flags),            \
            errcode);                                                          \
        return ret;                                                            \
    }                                                                          \
    BOOST_OUTCOME_C_MSVC_FORCE_EMIT(                                           \
        outcome_make_result_##ident##_failure_posix)                           \
    BOOST_OUTCOME_C_NODISCARD_EXTERN_C                                         \
    BOOST_OUTCOME_C_WEAK struct cxx_result_status_code_##ident                 \
        outcome_make_result_##ident##_failure_system(intptr_t errcode)         \
    {                                                                          \
        struct cxx_result_status_code_##ident ret;                             \
        assert(                                                                \
            outcome_make_result_status_code_failure_system); /* If this fails, \
                                                                you need to    \
                                                                compile this   \
                                                                file at least  \
                                                                once in C++.   \
                                                              */               \
        outcome_make_result_status_code_failure_system(                        \
            (void *)&ret,                                                      \
            sizeof(ret),                                                       \
            offsetof(struct cxx_result_status_code_##ident, flags),            \
            errcode);                                                          \
        return ret;                                                            \
    }                                                                          \
    BOOST_OUTCOME_C_MSVC_FORCE_EMIT(                                           \
        outcome_make_result_##ident##_failure_system)                          \
    BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE_CXX(ident, R, S)

#define BOOST_OUTCOME_C_RESULT_STATUS_CODE(ident)                              \
    struct cxx_result_status_code_##ident

#define BOOST_OUTCOME_C_TO_RESULT_STATUS_CODE(ident, ...)                      \
    to_##ident(__VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_SUCCESS(ident, ...)            \
    outcome_make_result_##ident##_success(__VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_FAILURE_POSIX(ident, ...)      \
    outcome_make_result_##ident##_failure_posix(__VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_FAILURE_SYSTEM(ident, ...)     \
    outcome_make_result_##ident##_failure_system(__VA_ARGS__)

struct cxx_status_code_posix
{
    void *domain;
    int value;
};

#define BOOST_OUTCOME_C_DECLARE_RESULT_ERRNO(ident, R)                         \
    BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE(                                \
        posix_##ident, R, struct cxx_status_code_posix)
#define BOOST_OUTCOME_C_RESULT_ERRNO(ident)                                    \
    BOOST_OUTCOME_C_RESULT_STATUS_CODE(posix_##ident)

struct cxx_status_code_system
{
    void *domain;
    intptr_t value;
};

#define BOOST_OUTCOME_C_DECLARE_RESULT_SYSTEM(ident, R)                        \
    BOOST_OUTCOME_C_DECLARE_RESULT_STATUS_CODE(                                \
        system_##ident, R, struct cxx_status_code_system)
#define BOOST_OUTCOME_C_RESULT_SYSTEM(ident)                                   \
    BOOST_OUTCOME_C_RESULT_STATUS_CODE(system_##ident)

#define BOOST_OUTCOME_C_TO_RESULT_SYSTEM_CODE(ident, ...)                      \
    to_system_##ident(__VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_SYSTEM_SUCCESS(ident, ...)                 \
    BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_SUCCESS(system_##ident, __VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_SYSTEM_FAILURE_POSIX(ident, ...)           \
    BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_FAILURE_POSIX(                     \
        system_##ident, __VA_ARGS__)
#define BOOST_OUTCOME_C_MAKE_RESULT_SYSTEM_FAILURE_SYSTEM(ident, ...)          \
    BOOST_OUTCOME_C_MAKE_RESULT_STATUS_CODE_FAILURE_SYSTEM(                    \
        system_##ident, __VA_ARGS__)

#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLV(                               \
    unique, retstmt, cleanup, spec, ...)                                       \
    BOOST_OUTCOME_TRYV2_UNIQUE_STORAGE(unique, spec, __VA_ARGS__);             \
    BOOST_OUTCOME_TRY_LIKELY_IF(BOOST_OUTCOME_C_RESULT_HAS_VALUE(unique));     \
    else                                                                       \
    {                                                                          \
        retstmt;                                                               \
    }
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLA(                               \
    unique, retstmt, cleanup, var, ...)                                        \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLV(                                   \
        unique, retstmt, cleanup, var, __VA_ARGS__)                            \
    BOOST_OUTCOME_TRY2_VAR(var) = unique.value

#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPL_RETURN(unique, ident)           \
    BOOST_OUTCOME_C_RESULT_SYSTEM(ident) unique##_f;                           \
    unique##_f.flags = (unique).flags;                                         \
    unique##_f.error = (unique).error;                                         \
    return unique##_f

#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
    unique, spec, ident, cleanup, ...)                                               \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLA(                                         \
        unique,                                                                      \
        BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPL_RETURN(unique, ident),                \
        cleanup,                                                                     \
        spec,                                                                        \
        __VA_ARGS__)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP(               \
    unique, spec, cleanup, ...)                                                \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLA(                                   \
        unique, return unique, cleanup, spec, __VA_ARGS__)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_CLEANUP(unique, cleanup, ...)   \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLV(                                   \
        unique, return unique, cleanup, deduce, __VA_ARGS__)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_SAME_RETURN_TYPE(unique, ...)        \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_IMPLV(                                   \
        unique, return unique, , deduce, __VA_ARGS__)

#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY8(a, b, c, d, e, f, g, h)    \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c, d, e, f, g, h)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY7(a, b, c, d, e, f, g)       \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c, d, e, f, g)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY6(a, b, c, d, e, f)          \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c, d, e, f)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY5(a, b, c, d, e)             \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c, d, e)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY4(a, b, c, d)                \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP_AND_NEW_RETURN_TYPE( \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c, d)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY3(a, b, c)                 \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_SPEC_AND_CLEANUP(                   \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b, c)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY2(a, b)                    \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_WITH_CLEANUP(                            \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, a, b)
#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY1(expr)                    \
    BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_SAME_RETURN_TYPE(                        \
        BOOST_OUTCOME_TRY_UNIQUE_NAME, expr)

#define BOOST_OUTCOME_C_RESULT_SYSTEM_TRY(...)                                 \
    BOOST_OUTCOME_TRY_CALL_OVERLOAD(                                           \
        BOOST_OUTCOME_C_RESULT_SYSTEM_TRY_INVOKE_TRY, __VA_ARGS__)

#define BOOST_OUTCOME_C_MAKE_RESULT_SYSTEM_FROM_ENUM(ident, enum_name, ...)    \
    outcome_make_result_##ident##_failure_system_enum_##enum_name(__VA_ARGS__)
#ifndef __cplusplus
    // Declares the function in C, needs to occur at least once in a C++ source
    // file to get implemented
    #define BOOST_OUTCOME_C_DECLARE_RESULT_SYSTEM_FROM_ENUM(                   \
        ident, enum_name, uuid, ...)                                           \
        BOOST_OUTCOME_C_NODISCARD_EXTERN_C struct                              \
            cxx_result_status_code_system_##ident                              \
                outcome_make_result_##ident##_failure_system_enum_##enum_name( \
                    enum enum_name v);
#else
}

    #include <boost/outcome/experimental/status_result.hpp>

    #if __has_include(                                                         \
        <boost/outcome/experimental/status-code/status-code/posix_code.hpp>)
        #include <boost/outcome/experimental/status-code/status-code/posix_code.hpp>
    #else
        #include <boost/outcome/experimental/status-code/posix_code.hpp>
    #endif

    #include <algorithm>
    #include <cstring>

    #if defined(__GNUC__) && !defined(__clang__)
        #pragma GCC diagnostic push
        #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
    #endif

// You need to include this C header in at least one C++ source file to have
// these C helper functions be implemented
extern "C" BOOST_OUTCOME_C_WEAK void
outcome_make_result_status_code_failure_posix(
    void *out, size_t bytes, size_t offset, int errcode)
{
    using value_type =
        BOOST_OUTCOME_V2_NAMESPACE::experimental::posix_code::value_type;

    union type_punner_t
    {
        BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<intptr_t> cpp;

        struct cxx_status_code
        {
            intptr_t value;
            unsigned flags;
            cxx_status_code_system error;
        } c;

        explicit type_punner_t(
            BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<intptr_t>
                res)
            : cpp(std::move(res))
        {
        }

        ~type_punner_t() {}
    } pun{BOOST_OUTCOME_V2_NAMESPACE::experimental::posix_code(errcode)};

    static_assert(sizeof(pun.cpp) == sizeof(pun.c), "");
    static constexpr size_t punoffset =
        offsetof(type_punner_t::cxx_status_code, flags);
    assert(bytes - offset >= sizeof(pun.cpp) - punoffset);
    size_t const tocopy = std::min(bytes - offset, sizeof(pun.cpp) - punoffset);
    memcpy(out, (void *)&pun.c, sizeof(value_type));
    memcpy(
        (void *)((char *)out + offset),
        (void const *)((char const *)&pun.c + punoffset),
        tocopy);
}
BOOST_OUTCOME_C_MSVC_FORCE_EMIT(outcome_make_result_status_code_failure_posix)

extern "C" BOOST_OUTCOME_C_WEAK void
outcome_make_result_status_code_failure_system(
    void *out, size_t bytes, size_t offset, intptr_t errcode)
{
    using value_type =
        BOOST_OUTCOME_V2_NAMESPACE::experimental::system_code::value_type;

    union type_punner_t
    {
        BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<intptr_t> cpp;

        struct cxx_status_code
        {
            intptr_t value;
            unsigned flags;
            cxx_status_code_system error;
        } c;

        explicit type_punner_t(
            BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<intptr_t>
                res)
            : cpp(std::move(res))
        {
        }

        ~type_punner_t() {}
    } pun{
    #ifdef _WIN32
        BOOST_OUTCOME_V2_NAMESPACE::experimental::win32_code(
            (BOOST_OUTCOME_V2_NAMESPACE::experimental::win32::DWORD)errcode)
    #else
        BOOST_OUTCOME_V2_NAMESPACE::experimental::posix_code((int)errcode)
    #endif
    };
    static_assert(sizeof(pun.cpp) == sizeof(pun.c), "");
    static constexpr size_t punoffset =
        offsetof(type_punner_t::cxx_status_code, flags);
    assert(bytes - offset >= sizeof(pun.cpp) - punoffset);
    size_t const tocopy = std::min(bytes - offset, sizeof(pun.cpp) - punoffset);
    memcpy(out, (void *)&pun.c, sizeof(value_type));
    memcpy(
        (void *)((char *)out + offset),
        (void const *)((char const *)&pun.c + punoffset),
        tocopy);
}
BOOST_OUTCOME_C_MSVC_FORCE_EMIT(outcome_make_result_status_code_failure_system)

extern "C" BOOST_OUTCOME_C_WEAK int
outcome_status_code_equal(void const *_a, void const *_b)
{
    auto const *a =
        (const BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::system_code *)_a;
    auto const *b =
        (const BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::system_code *)_b;
    return *a == *b;
}
BOOST_OUTCOME_C_MSVC_FORCE_EMIT(outcome_status_code_equal)

extern "C" BOOST_OUTCOME_C_WEAK int
outcome_status_code_equal_generic(void const *_a, int errcode)
{
    auto const *a =
        (const BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::system_code *)_a;
    return *a == (BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::errc)errcode;
}
BOOST_OUTCOME_C_MSVC_FORCE_EMIT(outcome_status_code_equal_generic)

extern "C" BOOST_OUTCOME_C_WEAK const char *
outcome_status_code_message(void const *_a)
{
    static thread_local BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::system_code::
        string_ref msg((char const *)nullptr, 0);
    auto const *a =
        (const BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE::system_code *)_a;
    msg = a->message();
    return msg.c_str();
}
BOOST_OUTCOME_C_MSVC_FORCE_EMIT(outcome_status_code_message)

BOOST_OUTCOME_V2_NAMESPACE_BEGIN

namespace experimental
{
    namespace detail
    {
        template <class RetType, class EnumType>
        inline RetType outcome_make_result_failure_system_enum(EnumType v)
        {
            using value_type = BOOST_OUTCOME_V2_NAMESPACE::experimental::
                system_code::value_type;

            union type_punner_t
            {
                BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<
                    intptr_t>
                    cpp;

                struct cxx_status_code
                {
                    intptr_t value;
                    unsigned flags;
                    cxx_status_code_system error;
                } c;

                explicit type_punner_t(
                    BOOST_OUTCOME_V2_NAMESPACE::experimental::status_result<
                        intptr_t>
                        res)
                    : cpp(std::move(res))
                {
                }

                ~type_punner_t() {}
            } pun{BOOST_OUTCOME_V2_NAMESPACE::experimental::
                      quick_status_code_from_enum_code<EnumType>(v)};

            static constexpr size_t bytes = sizeof(RetType);
            static constexpr size_t offset = offsetof(RetType, flags);
            static constexpr size_t punoffset =
                offsetof(typename type_punner_t::cxx_status_code, flags);
            assert(bytes - offset >= sizeof(pun.cpp) - punoffset);
            size_t const tocopy =
                std::min(bytes - offset, sizeof(pun.cpp) - punoffset);
            RetType ret;
            memcpy(&ret, (void *)&pun.c, sizeof(value_type));
            memcpy(
                (void *)((char *)&ret + offset),
                (void const *)((char const *)&pun.c + punoffset),
                tocopy);
            return ret;
        }
    } // namespace detail
} // namespace experimental

BOOST_OUTCOME_V2_NAMESPACE_END

    // Unique UUID for the enum PLEASE use
    // https://www.random.org/cgi-bin/randbyte?nbytes=16&format=h
    // .. is sequence of {enum_name::value, "text description",
    // {errc::equivalent, ...}},
    #define BOOST_OUTCOME_C_DECLARE_RESULT_SYSTEM_FROM_ENUM(                   \
        ident, enum_name, uuid, ...)                                           \
        BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE_BEGIN                            \
        template <>                                                            \
        struct quick_status_code_from_enum<enum enum_name>                     \
            : quick_status_code_from_enum_defaults<enum enum_name>             \
        {                                                                      \
            static constexpr const auto domain_name = #enum_name;              \
            static constexpr const auto domain_uuid = uuid;                    \
            static const std::initializer_list<mapping> &value_mappings()      \
            {                                                                  \
                static const std::initializer_list<mapping> v = {__VA_ARGS__}; \
                return v;                                                      \
            }                                                                  \
        };                                                                     \
        BOOST_OUTCOME_SYSTEM_ERROR2_NAMESPACE_END                              \
        extern "C" BOOST_OUTCOME_C_NODISCARD                                   \
            BOOST_OUTCOME_C_WEAK struct cxx_result_status_code_system_##ident  \
                outcome_make_result_##ident##_failure_system_enum_##enum_name( \
                    enum enum_name v)                                          \
        {                                                                      \
            return BOOST_OUTCOME_V2_NAMESPACE::experimental::detail::          \
                outcome_make_result_failure_system_enum<                       \
                    struct cxx_result_status_code_system_##ident>(v);          \
        }                                                                      \
        BOOST_OUTCOME_C_MSVC_FORCE_EMIT(                                       \
            outcome_make_result_##ident##_failure_system_enum_##enum_name)

    #if defined(__GNUC__) && !defined(__clang__)
        #pragma GCC diagnostic pop
    #endif

#endif

#endif
