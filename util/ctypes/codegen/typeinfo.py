"""Type definition TOML files are loaded into this common Python representation
before being passed to code generators for various language backends."""

import enum
import graphlib
import hashlib
import io
import pathlib
import sys
import tomllib

from enum import auto, Enum
from dataclasses import dataclass
from typing import BinaryIO, Mapping, Optional, Self

class IntrinsicType(Enum):
  bool = auto()
  i32 = auto()
  i64 = auto()
  u8 = auto()
  u16 = auto()
  u32 = auto()
  u64 = auto()
  u128 = auto()

@dataclass
class TypeInfo:
  module_name: str     # Module where type is defined
  type_name: str       # Identifier name of the type, in snake case
  doc_comment: str     # Documentation comment for the type
  lang_attrs: dict     # Language-specific attributes
  event_name: str|None # Name of associated event payload, none if not an event type

  @property
  def qual_name(self) -> str:
    return f'{self.module_name}.{self.type_name}'

  def fingerprint(self) -> bytes:
    return self.qual_name.encode()

@dataclass
class FieldInfo:
  name: str            # Identifier name of the field, in snake case
  type_info: TypeInfo  # Type of the field
  doc_comment: str     # Documentation comment for the field (short, trailing)
  trailing_array_element_type: TypeInfo|None  # Element type of trailing array

  @property
  def is_byte_vlta_size(self) -> bool:
    return isinstance(self.trailing_array_element_type, IntrinsicTypeInfo) and \
           self.trailing_array_element_type.intrinsic_type is IntrinsicType.u8

  def fingerprint(self) -> bytes:
    t = self.trailing_array_element_type
    return self.name.encode() + self.type_info.fingerprint() + \
        (t.fingerprint() if t else b'')

@dataclass
class IntrinsicTypeInfo(TypeInfo):
  intrinsic_type: IntrinsicType

@dataclass
class EnumTypeInfo(TypeInfo):
  underlying_type: TypeInfo     # Integral type for enum storage
  values: list[tuple[str, int]] # Enumeration constant mapping

  def fingerprint(self) -> bytes:
    fp_buf = io.BytesIO()
    for k, v in self.values:
      fp_buf.write(k.encode() + v.to_bytes(byteorder=sys.byteorder))
    return super().fingerprint() + self.underlying_type.fingerprint() + fp_buf.getvalue()

@dataclass
class AliasTypeInfo(TypeInfo):
  underlying_type: TypeInfo  # Type for which this is an alias
  strong: bool               # True -> behave as separate type (take definition)

  def fingerprint(self) -> bytes:
    return super().fingerprint() + self.underlying_type.fingerprint()

@dataclass
class RecordTypeInfo(TypeInfo):
  fields: list[FieldInfo]  # Information about each field

  def fingerprint(self) -> bytes:
    return super().fingerprint() + b''.join(f.fingerprint() for f in self.fields)

@dataclass
class ExternalTypeInfo(TypeInfo):
  """External types are not generated by us, but have some kind of "intrinsic"
  support in whatever backend language we're targetting; the purpose of this
  type is to organize (on a per-language basis) the the string names of the
  lowering targets, e.g., in C bytes32 lowers to `monad_c_bytes32` (defined
  manually elsewhere) and in Rust it lowers to `alloy_primitives::B256`."""
  lang_lowering_map: Mapping[str, str] # Language name -> intrinsic type

@dataclass
class EmptyTypeInfo(TypeInfo):
  # Types which have no content; used to emit marker events with empty payloads
  pass

@dataclass
class EventConfig:
  event_ring_type: str      # Short name of event ring type, e.g., 'exec'

@dataclass
class ModuleInfo:
  name: str                           # Name of the type module
  type_defs: Mapping[str, TypeInfo]   # All types defined by the module
  dependencies: list[Self]            # Dependencies of this module
  doc_comment: str                    # File-level comment
  lang_attrs: dict                    # Language-specific attributes
  event_config: Optional[EventConfig] # Config for "event ring" payload type modules
  origin_file: Optional[pathlib.Path] # Loaded from this TOML file

  def fingerprint(self) -> bytes:
    fp_buf = io.BytesIO()
    for td in self.type_defs.values():
      fp_buf.write(td.fingerprint())
    return fp_buf.getvalue()

  def compute_hash(self) -> bytes:
    m = hashlib.sha256()
    m.update(self.fingerprint())
    return m.digest()

  def lookup_type(self, type_name: str) -> tuple[Optional[Self], Optional[TypeInfo]]:
    modules = [self]
    visited_modules = set()
    while modules:
      search_module = modules.pop(0)
      ty = search_module.type_defs.get(type_name, None)
      if ty:
        return search_module, ty
      if search_module.name not in visited_modules:
        visited_modules.add(search_module.name)
        modules += search_module.dependencies
    return None, None

  @property
  def is_event_module(self) -> bool:
    return bool(self.event_config)

  @property
  def event_count(self) -> int:
    return sum(1 for td in self.type_defs.values() if td.event_name)

  @property
  def is_external_only(self) -> bool:
    # When True, nothing defined in this module generates any code
    return all(isinstance(td, (IntrinsicTypeInfo, ExternalTypeInfo))
                          for td in self.type_defs.values())

# The module defining the intrinsic types is builtin
IntrinsicModule = ModuleInfo(
  name = '<intrinsic>',
  type_defs = {
     i.name: IntrinsicTypeInfo(
     module_name = 'intrinsic',
     type_name = i.name,
     doc_comment = f'{i.name} (intrinsic)',
     lang_attrs = dict(),
     event_name = None,
     intrinsic_type = i) for i in IntrinsicType},
  dependencies = [],
  doc_comment = "Types which are intrinsically understood by the language backend",
  lang_attrs = dict(),
  event_config = None,
  origin_file = None)

# Event external types

EventExternalModule = ModuleInfo(
  name = '<event>',
  type_defs = {
    'event_record_error': ExternalTypeInfo(
      module_name = 'event_external',
      type_name = 'event_record_error',
      doc_comment = 'event_record_error (event_ring builtin)',
      lang_attrs = dict(),
      event_name = None,
      lang_lowering_map = {
        'c': 'struct monad_event_record_error',
        'rust': 'monad_event_record_error'
      })
  },
  dependencies = [],
  doc_comment = "Types which are provided by the event ring API",
  lang_attrs = dict(),
  event_config = None,
  origin_file = None)

def lookup_type(module_types: Mapping[str, TypeInfo],
                dependencies: list[ModuleInfo],
                type_name: str,
                error_ctx: str) -> TypeInfo:
  ty = module_types.get(type_name)
  if ty:
    return ty
  for m in dependencies:
    _, ty = m.lookup_type(type_name)
    if ty:
      return ty
  raise ValueError(f'failed to look up type {type_name} in {error_ctx}')

def get_value(decl: dict, key: str, Type: type, context: str, *, required: bool = True) -> any:
  value = decl.get(key, None)
  if value is None and not required:
    return None
  if value is None:
    raise ValueError(f'{context} does not have required "{key}" key')
  if not isinstance(value, Type):
    raise ValueError(f'{context} value for key "{key}" does not have '
                     f'expected type {Type.__name__}')
  return value

def get_doc_comment(decl: dict, context: str) -> str:
  return get_value(decl, 'doc', str, context)

def get_event_name(decl: dict, type_name: str, is_event_module: bool,
                   context: str) -> str|None:
  if not is_event_module:
    return None
  v = get_value(decl, 'event_name', str, context, required=False)
  if v is None:
    # event_name not present; use the type's name as the event name
    return type_name
  elif not v:
    # event_name is explicitly present, but is an empty string; this is used
    # to explicitly "opt out" of being an event payload type despite being in
    # an event type module, e.g., the execution flow type. TOML doesn't
    # support null values so we need to do it this odd way.
    return None
  else:
    return v

def create_enum_type(module_name: str, type_name: str, enum_decl: dict,
                     module_types: Mapping[str, TypeInfo],
                     dependencies: list[ModuleInfo],
                     is_event_module: bool) -> EnumTypeInfo:
  # Enumeration types must specify the underlying integral type
  context = f'enum type {module_name}:{type_name}'
  underlying_type_name = get_value(enum_decl, 'underlying_type', str, context)
  underlying_type = lookup_type(module_types, dependencies, underlying_type_name,
                                f'{context} underlying_type lookup')

  # Validate that the values table is all entries of the form `name` = `value`
  values = get_value(enum_decl, 'values', dict, context)
  for key, value in values.items():
    if not key.isidentifier():
      raise ValueError(f'enumeration constant {key} in {context} is not a valid identifier')
    if not isinstance(value, int):
      raise ValueError(f'enumeration constant {key} in {context} is not integral')

  return EnumTypeInfo(
      module_name = module_name,
      type_name = type_name,
      doc_comment = get_doc_comment(enum_decl, context),
      lang_attrs = get_value(enum_decl, 'lang', dict, context, required=False) or dict(),
      event_name = get_event_name(enum_decl, type_name, is_event_module, context),
      underlying_type = underlying_type,
      values = list(values.items()))

def create_alias_type(module_name: str, type_name: str, alias_decl: dict,
                      module_types: Mapping[str, TypeInfo],
                      dependencies: list[ModuleInfo],
                      is_event_module: bool) -> AliasTypeInfo:
  context = f'alias type {module_name}:{type_name}'
  alias_dict = get_value(alias_decl, 'alias', dict, context)
  underlying_type_name = get_value(alias_dict, 'underlying_type', str, context)
  underlying_type = lookup_type(module_types, dependencies, underlying_type_name,
                                f'{context} underlying_type lookup')
  strong = get_value(alias_dict, 'strong', bool, context)

  return AliasTypeInfo(
      module_name = module_name,
      type_name = type_name,
      doc_comment = get_doc_comment(alias_decl, context),
      lang_attrs = get_value(alias_decl, 'lang', dict, context, required=False) or dict(),
      event_name = get_event_name(alias_decl, type_name, is_event_module, context),
      underlying_type = underlying_type,
      strong = strong)

def create_record_type(module_name: str, type_name: str, record_decl: dict,
                       module_types: Mapping[str, TypeInfo],
                       dependencies: list[ModuleInfo],
                       is_event_module: bool) -> RecordTypeInfo:
  fields = list()

  record_context = f'record type {module_name}:{type_name}'
  field_decls = get_value(record_decl, 'fields', dict, record_context)
  for field_name, field_decl in field_decls.items():
    if not field_name.isidentifier():
      raise ValueError(f'field name {fielde_name} in {record_context} is not an identifier')

    # Look up the field type by name
    field_context = f'field {field_name} in {record_context}'
    field_type_name = get_value(field_decl, 'type', str, field_context)
    field_type = lookup_type(module_types, dependencies, field_type_name,
                             field_context)

    field_doc_comment = get_doc_comment(field_decl, field_context)
    trailing_type_name = get_value(field_decl, 'trailing_array_element_type', str,
                                   field_context, required=False)
    if trailing_type_name:
      trailing_type = lookup_type(module_types, dependencies, trailing_type_name,
                                  f'trailing_array_element_type in {field_context}')
    else:
      trailing_type = None

    fields.append(FieldInfo(
        name = field_name,
        type_info = field_type,
        doc_comment = field_doc_comment,
        trailing_array_element_type = trailing_type))

  return RecordTypeInfo(
      module_name = module_name,
      type_name = type_name,
      doc_comment = get_doc_comment(record_decl, record_context),
      lang_attrs = get_value(record_decl, 'lang', dict, record_context,
                             required=False) or dict(),
      event_name = get_event_name(record_decl, type_name, is_event_module,
                                  record_context),
      fields = fields)

def create_external_type(module_name: str, type_name: str, extern_decl: dict) -> ExternalTypeInfo:
  context = f'external type {module_name}:{type_name}'
  lang_lowering_map = get_value(extern_decl, 'external', dict, context)
  for k, v in lang_lowering_map.items():
    if not isinstance(v, str):
      raise ValueError(f'{context} defines a language backend `{k}` whose '
                       f'lowering target is non-string value `{v}`')

  return ExternalTypeInfo(
      module_name = module_name,
      type_name = type_name,
      doc_comment = get_doc_comment(extern_decl, context),
      lang_attrs = get_value(extern_decl, 'lang', dict, context,
                             required=False) or dict(),
      event_name = None,
      lang_lowering_map = lang_lowering_map)

def create_module(module_name: str, dependencies: list[ModuleInfo],
                  module_toml: dict, origin_file: pathlib.Path) -> ModuleInfo:
  module_doc_comment = None
  event_config = None
  lang_attrs = dict()
  types = dict()

  for type_no, (type_name, type_decl) in enumerate(module_toml.items()):
    if type_name == 'settings':
      if type_no != 0:
        raise ValueError(f'module {module_name} error: [settings] key is '
                         'present, but is not the first document item')
      if not isinstance(type_decl, dict):
        raise ValueError(f'module {module_name} settings value is not a table')
      module_context = f'module {module_name} [settings]'
      module_doc_comment = get_doc_comment(type_decl, module_context)
      lang_attrs = get_value(type_decl, 'lang', dict, module_context,
                             required=False) or dict()
      event_config = get_value(type_decl, 'event', dict, module_context,
                               required=False)
      if event_config:
        event_config_context = f'module {module_name} [event settings]'
        event_ring_type = get_value(event_config, 'event_ring_type', str,
                                    event_config_context)
        event_config = EventConfig(event_ring_type=event_ring_type)

        # Inject the NONE and RECORD_ERROR event types
        types['none'] = EmptyTypeInfo(
            module_name = module_name,
            type_name = 'none',
            doc_comment = 'Reserved code so that 0 remains invalid',
            lang_attrs = dict(),
            event_name = 'none')

        # The RECORD_ERROR type is a type alias for monad_event_record_error,
        # which is extenrally defined (by event_ring.h)
        event_ext_module, event_record_error = \
            EventExternalModule.lookup_type('event_record_error')
        types['record_error'] = AliasTypeInfo(
            module_name = module_name,
            type_name = 'record_error',
            doc_comment = 'Reserved event type used for recording errors',
            lang_attrs = dict(),
            event_name = 'record_error',
            underlying_type = event_record_error,
            strong = False)

      # Don't try to generate types from the 'settings' element
      continue

    # Type names must follow Python identifier rules, which approximately match
    # the identifier rules for all supported languages (C, Rust, etc.). There
    # may be minor disagreements around strange unicode characters, but we
    # don't care.
    if not type_name.isidentifier():
      raise ValueError(f'type name {type_name} in {module_name} is not an identifier')

    # Determine the appropriate type given the kind of keys we find in its
    # declaration
    is_event_module = event_config is not None
    if 'values' in type_decl:
      type_info = create_enum_type(module_name, type_name, type_decl,
                                   types, dependencies, is_event_module)
    elif 'alias' in type_decl:
      type_info = create_alias_type(module_name, type_name, type_decl,
                                    types, dependencies, is_event_module)
    elif 'fields' in type_decl:
      type_info = create_record_type(module_name, type_name, type_decl,
                                     types, dependencies, is_event_module)
    elif 'external' in type_decl:
      type_info = create_external_type(module_name, type_name, type_decl)
    elif 'empty_marker' in type_decl:
      context = f'empty marker type {module_name}:{type_name}'
      type_info = EmptyTypeInfo(
        module_name = module_name,
        type_name = type_name,
        doc_comment = get_doc_comment(type_decl, context),
        lang_attrs = get_value(type_decl, 'lang', dict, context, required=False) or dict(),
        event_name = get_event_name(type_decl, type_name, is_event_module, context))
    else:
      raise ValueError(f'could not deduce type family of {module_name}:{type_name}')

    types[type_name] = type_info

  return ModuleInfo(
      name=module_name,
      type_defs=types,
      dependencies=dependencies,
      doc_comment=module_doc_comment,
      lang_attrs=lang_attrs,
      event_config=event_config,
      origin_file=origin_file)

def load_type_modules(source_paths: list[pathlib.Path]) -> Mapping[str, ModuleInfo]:
  # Type definitions are loaded from '.toml' files; these can given individually
  # or as source directories, which glob all '.toml' files in that directory.
  # Each TOML file defines a module, whose name is the TOML filename stem, in
  # lowercase.
  module_name_to_toml = dict()
  module_name_to_path = dict()

  for p in source_paths:
    if p.is_file():
      source_files = [p]
    elif p.is_dir():
      source_files = p.glob('*.toml')
    else:
      raise ValueError('{p} is not an accessible regular file or directory')
    for def_file in source_files:
      with open(def_file, "rb") as toml_file:
        try:
          toml = tomllib.load(toml_file)
        except Exception as ex:
          raise ValueError(f'unable to load type module {def_file}') from ex
      module_name_to_toml[def_file.stem.lower()] = toml
      module_name_to_path[def_file.stem.lower()] = def_file

  # Grouping types into modules is only for organization's sake; modules do not
  # introduce separate namespaces. All types exist in a single global namespace,
  # and must be unique. However, a module must explicitly declare its dependency
  # on another module, if it uses types defined in that module. These explicit
  # declarations are used to topologically sort the modules, so that types are
  # always defined in "definition before use" order. The settings.depends key
  # is an array listing the dependencies.
  module_dependency_map = dict()
  has_event_module = False
  for module_name, toml in module_name_to_toml.items():
    if 'settings' not in toml:
      toml['settings'] = dict() # No settings key; inject empty settings
    elif not isinstance(toml['settings'], dict):
      raise ValueError(f'type module {module_name} `settings` key is not a table')

    depends = toml['settings'].get('depends', [])
    if not isinstance(depends, list):
      raise ValueError(f'type module {module_name} `settings.depends` values is not an array')

    # Everything depends on the intrinsic module
    depends.insert(0, IntrinsicModule.name)

    event_config = toml['settings'].get('event', {})
    if event_config:
      # A settings.event key means this is an event module; these depend on
      # the EventExternalModule too
      depends.append(EventExternalModule.name)
      has_event_module = True

    # This map will have the structure of a directed graph adjacency list,
    # which can be used directly by graphlib's TopologicalSorter
    module_dependency_map[module_name] = depends

  module_map = {IntrinsicModule.name: IntrinsicModule}
  if has_event_module:
    module_map[EventExternalModule.name] = EventExternalModule

  # Visit the modules in dependency order
  for module_name in graphlib.TopologicalSorter(module_dependency_map).static_order():
    if module_name in (IntrinsicModule.name, EventExternalModule.name):
      continue # Skip this one
    dependent_modules = [module_map[n] for n in module_dependency_map[module_name]]
    module_map[module_name] = create_module(module_name, dependent_modules,
                                            module_name_to_toml[module_name],
                                            module_name_to_path[module_name])

  return module_map

__all__ = [
  'AliasTypeInfo',
  'EmptyTypeInfo',
  'EnumTypeInfo',
  'ExternalTypeInfo',
  'IntrinsicType',
  'IntrinsicTypeInfo',
  'ModuleInfo',
  'RecordTypeInfo',
  'TypeInfo',
  'load_type_modules',
]
