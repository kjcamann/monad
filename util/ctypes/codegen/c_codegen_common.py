"""C code generation helper; this allows the C code generator and the
C++20 std::formatter specialization generator to share some common code
"""

import argparse
import pathlib
import shutil
import subprocess
import sys
import textwrap

from typing import Mapping, Optional
from typeinfo import *

C_CODEGEN_WARNING_FORMAT = \
"""// WARNING: THIS FILE CONTAINS GENERATED CODE, DO NOT EDIT MANUALLY! If
// you need changes, change the code generator or its inputs instead. This
// file was generated by running the following command:
//
{0}"""

GPL_V3_LICENSE_COMMENT = \
"""// Copyright (C) 2025 Category Labs, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>."""

def create_command_comment() -> str:
  """Create a comment that describes how the code generator was run; this
  is written into the prologue replacing the `{0}` format element"""

  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in
                  textwrap.wrap(cmdline, break_long_words=False, break_on_hyphens=False))
  return '\n'.join(invoke_lines)

# Intrinsic types are lowered to builtins or <stdint.h> types
IntrinsicTypeMap = {
  IntrinsicType.bool : 'bool',
  IntrinsicType.i32 : 'int32_t',
  IntrinsicType.i64 : 'int64_t',
  IntrinsicType.u8 : 'uint8_t',
  IntrinsicType.u16 : 'uint16_t',
  IntrinsicType.u32 : 'uint32_t',
  IntrinsicType.u64 : 'uint64_t',
}

def get_c_type_name_prefix(module: ModuleInfo) -> str:
  """Non-intrinsic type names start with a prefix, i.e., `monad_<something>`.
  By default this is `monad_c`, but event type modules name the prefix
  after the event ring short name, and it can be overridden by the module's
  `prefix` C language attribute."""
  default_prefix = 'monad_c'
  if module.is_event_module:
    default_prefix = f'monad_{module.event_config.event_ring_type}'
  type_prefix = module.lang_attrs.get('c', {}).get('prefix', default_prefix)
  if not isinstance(type_prefix, str) or not type_prefix.isidentifier():
    raise ValueError(f'module `{module.name}` has invalid type prefix `{type_prefix}`')
  return type_prefix

def get_c_type_name(lookup_module: ModuleInfo, type_info: TypeInfo,
                    elaborated_type_specifier: bool = False) -> str:
  """Returns a type's name, as it should appear in C declarations"""
  if isinstance(type_info, IntrinsicTypeInfo):
    return IntrinsicTypeMap[type_info.intrinsic_type]

  declaring_module, _ = lookup_module.lookup_type(type_info.type_name)
  type_prefix = get_c_type_name_prefix(declaring_module)
  c_type_name = f'{type_prefix}_{type_info.type_name}'

  if isinstance(type_info, EnumTypeInfo):
    return f'enum {c_type_name}' if elaborated_type_specifier else c_type_name
  elif isinstance(type_info, AliasTypeInfo):
    assert not type_info.strong
    # Emitted as typedefs, so we don't need a struct or enum tag
    return c_type_name
  elif isinstance(type_info, RecordTypeInfo):
    return f'struct {c_type_name}' if elaborated_type_specifier else c_type_name
  elif isinstance(type_info, ExternalTypeInfo):
    c_type_name = type_info.lang_lowering_map.get('c', None)
    if not c_type_name:
      raise ValueError(f'external type {type_info.qualname} has no C lowering target')
    return c_type_name
  else:
    assert False, 'missing support for this type family'

def get_module_header_path(module: ModuleInfo,
                           alternate_dir: Optional[pathlib.Path] = None) -> pathlib.Path:
  if not alternate_dir:
    alternate_dir = module.lang_attrs.get('c', {}).get('header_output_dir', None)
    if not isinstance(alternate_dir, str):
      raise ValueError(f'module `{module.name}` is missing a header output directory')
    alternate_dir = pathlib.Path(alternate_dir)
  return alternate_dir / f'{module.name}.h'

def try_run_clang_format(clang_format_path: Optional[str],
                         clang_format_args: str,
                         source_path: pathlib.Path):
  if clang_format_path is None:
    return
  cmd_args = [clang_format_path, '-i', str(source_path)]
  if clang_format_args:
    cmd_args.insert(1, clang_format_args)
  subprocess.run(cmd_args, check=True, capture_output=True)

def setup_c_backend_common_args(subparser, language: str):
  output_group = subparser.add_mutually_exclusive_group(required=True)

  output_group.add_argument('-s', '--stdout', action='store_true',
      help=f'write {language} source files to stdout, for debugging')

  output_group.add_argument('-p', '--path', action='store',
      type=pathlib.Path, metavar='<dir>',
      help='output directory where generated source code files will be written')

  subparser.add_argument('-f', '--clang-format', nargs='?',
      const='clang-format', metavar='<clang-format-command>',
      help='run clang-format on the output, after it is produced')

  subparser.add_argument('--no-warning', action='store_true',
      help='do not include the "this is generated code" warning message')

def check_c_backend_common_args(args: argparse.Namespace) -> str:
  clang_format_args = ''
  if args.stdout and args.clang_format:
    raise ValueError('--clang-format is not compatible with --stdout; '
                     'pipe stdout to clang-format instead')

  if args.clang_format:
    format_cmd, _, clang_format_args = args.clang_format.partition(' ')
    format_cmd_path = shutil.which(format_cmd)
    if not format_cmd_path:
      raise ValueError(f'--clang-format executable `{format_cmd}` not on PATH')
    args.clang_format = format_cmd_path

  if args.path and not args.path.is_dir():
    raise ValueError(f'{args.path} is not a valid directory')

  return clang_format_args
