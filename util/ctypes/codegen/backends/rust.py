import argparse
import copy
import pathlib
import shutil
import subprocess
import sys
import textwrap

from typing import Mapping, Optional, TextIO
from typeinfo import *

#
# type module content and functions
#

GPL_V3_LICENSE_COMMENT = \
"""// Copyright (C) 2025 Category Labs, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>."""

MODULE_PROLOGUE = \
"""// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
{command_comment}

{module_comment}

#![allow(non_camel_case_types)]
#![allow(unused_imports)]

{use_decls}"""

def create_command_comment() -> str:
  cmdline = ' '.join(sys.argv)
  invoke_lines = (f'//    {line}' for line in textwrap.wrap(cmdline))
  return '\n'.join(invoke_lines)

IntrinsicTypeMap = {
  IntrinsicType.bool : 'bool',
  IntrinsicType.i32 : 'i32',
  IntrinsicType.i64 : 'i64',
  IntrinsicType.u8 : 'u8',
  IntrinsicType.u16 : 'u16',
  IntrinsicType.u32 : 'u32',
  IntrinsicType.u64 : 'u64',
}

def get_rust_type_name(type_info: TypeInfo) -> str:
  if isinstance(type_info, IntrinsicTypeInfo):
    return IntrinsicTypeMap[type_info.intrinsic_type]
  elif isinstance(type_info, ExternalTypeInfo):
    rust_type_name = type_info.lang_lowering_map.get('rust', None)
    if not rust_type_name:
      raise ValueError(f'external type `{type_info.qualname}` has no lowering '
                       'target in the Rust language')
    return rust_type_name
  return type_info.type_name

def emit_module_prologue(module: ModuleInfo, out: TextIO):
  file_comment_lines = (f'//! {line}' for line in textwrap.wrap(module.doc_comment))
  module_use_lines = list(f'use crate::{md.name}::*;' for md in module.dependencies
                          if not md.is_external_only)

  # Breadth-first-search visit the module's dependencies, adding in any use_decls
  # TODO(ken): this adds use decls we might not need...
  visited_deps = set()
  visit_queue = copy.copy(module.dependencies)
  while visit_queue:
    dep = visit_queue.pop(0)
    module_use_lines += [f'use {ud};' for ud in
                         dep.lang_attrs.get('rust', {}).get('use_decls', [])]
    visited_deps.add(dep.name)
    for child_dep in dep.dependencies:
      if child_dep.name not in visited_deps:
        visit_queue.append(child_dep)

  if module.is_event_module:
    module_use_lines += [
      'use monad_event_ring::event_metadata::*;',
      'use monad_event_ring::event_ring::monad_event_record_error;'
    ]

  if module_use_lines:
    module_use_lines += ['']
  print(GPL_V3_LICENSE_COMMENT, file=out)
  print(file=out) # Skip a line
  print(MODULE_PROLOGUE.format(
      command_comment = create_command_comment(),
      module_comment = '\n'.join(file_comment_lines),
      use_decls = '\n'.join(module_use_lines)), file=out)

def emit_type_comment(comment: str, out: TextIO):
  comment_lines = list()
  for paragraph in comment.split('\n\n'):
    # Wrap the lines in the paragraph, then add an extra blank line to preserve
    # the paragraph nature.
    comment_lines += textwrap.wrap(paragraph, width=80-len('/// ')) + ['']
  comment_lines.pop(-1)
  print('\n'.join(f'/// {c}'.strip() for c in comment_lines), file=out)

def emit_enum_type(enum_info: EnumTypeInfo, out: TextIO):
  emit_type_comment(enum_info.doc_comment, out)
  storage_type = get_rust_type_name(enum_info.underlying_type)

  print(
f"""#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
#[repr({storage_type})]
pub enum {enum_info.type_name} {{""", file=out)
  last_value = -1
  for name, value in enum_info.values:
    if value != last_value + 1:
      raise ValueError(f'cannot lay out non-monotonic enum {enum_info.qual_name} '
                       'in Rust with current codegen strategy')
    if value == 0:
      print('    #[default]', file=out)
    print(f'    {name.upper()},', file=out)
    last_value = value
  print('}\n', file=out)

def emit_alias_type(alias_info: AliasTypeInfo, out:TextIO):
  emit_type_comment(alias_info.doc_comment, out)
  storage_type = get_rust_type_name(alias_info.underlying_type)

  assert not alias_info.strong, 'no lowering strategy for strong typedefs in Rust yet'
  print(f'pub type {alias_info.type_name} = {storage_type};\n', file=out)

def emit_struct_type(struct_info: RecordTypeInfo, out: TextIO):
  emit_type_comment(struct_info.doc_comment, out)
  print(
f"""#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct {struct_info.type_name} {{""", file=out)

  field_decl_lines: list[list[str]] = []
  max_field_decl_len = 0
  field_indent = 4
  for field_info in struct_info.fields:
    storage_type = get_rust_type_name(field_info.type_info)
    field_decl = f'pub {field_info.name}: {storage_type},'
    if len(field_decl) + field_indent > 40:
      decl_lines = [f'pub {field_info.name}:', f'{"":>{field_indent}}{storage_type},']
    else:
      decl_lines = [field_decl]
    max_field_decl_len = max(max_field_decl_len, max(len(c) for c in decl_lines))
    field_decl_lines.append(decl_lines)

  max_field_decl_len = min(max_field_decl_len, 40)
  for field_info, decl_lines in zip(struct_info.fields, field_decl_lines):
    if len(decl_lines) == 1:
      print(f'{"":{field_indent}}{decl_lines[0]:<{max_field_decl_len}}'
            f' // {field_info.doc_comment}', file=out)
    else:
      assert len(decl_lines) == 2
      print(f'{"":{field_indent}}{decl_lines[0]}', file=out)
      print(f'{"":{field_indent}}{decl_lines[1]:<{max_field_decl_len}}'
            f' // {field_info.doc_comment}', file=out)

  print('}\n', file=out)

def emit_format_as_function(module: ModuleInfo, out: TextIO):
  event_ring_type = module.event_config.event_ring_type
  event_enum_type = f'{event_ring_type}_event_type'
  print(
f'''pub fn format_as(bytes: &[u8], event_type: {event_enum_type}) -> String {{
    match event_type {{''', file=out)

  indent = ' ' * 8
  for td in module.type_defs.values():
    if not td.event_name or isinstance(td, EmptyTypeInfo):
      continue
    enum_constant = td.event_name.upper()
    print(f'{indent}{event_enum_type}::{enum_constant} => format!("{{:?}}", ' + 
          f'unsafe {{ *(bytes.as_ptr() as *const {get_rust_type_name(td)}) }} ),',
          file=out)
  print(f'{indent}_ => String::new(),', file=out)
  print('    }\n}', file=out)

def emit_event_enum_type(module: ModuleInfo, out: TextIO):
  event_ring_type = module.event_config.event_ring_type
  print(
f"""/// Each type of event is assigned a unique value in this enumeration
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
#[repr(u16)]
pub enum {event_ring_type}_event_type
{{
    #[default]""", file=out)

  for td in module.type_defs.values():
    if td.event_name:
      print(f'    {td.event_name.upper()},', file=out)

  print('}\n', file=out)

def emit_event_metadata_array(module: ModuleInfo, out: TextIO):
  event_ring_type = module.event_config.event_ring_type
  metadata_array_name = f'{event_ring_type.upper()}_EVENT_METADATA'
  n_types = module.event_count
  print(f'''
pub const {metadata_array_name}: [EventMetadata; {n_types}] = [''', file=out)
  for td in module.type_defs.values():
    if not td.event_name:
      continue
    name_upper = td.event_name.upper()
    short_doc_comment = td.doc_comment.split('\n')[0]
    print(f'''
    EventMetadata {{
        event_type: {event_ring_type}_event_type::{name_upper} as u16,
        c_name: "{name_upper}",
        description: "{short_doc_comment}",
    }},''', file=out)
  print('];', file=out)

  hash_initializer_lines = list()
  evt_hash = module.compute_hash()
  for b in range(0, 32, 8):
    hash_initializer_lines.append(', '.join(f'{b:#02x}' for b in evt_hash[b:b+8]))

  print(f"""
pub static {event_ring_type.upper()}_EVENT_DOMAIN_METADATA: EventDomainMetadata = EventDomainMetadata {{
    schema_hash: [
{'\n'.join(f'{"":>8}{line},' for line in hash_initializer_lines)}
    ],
    events: &{metadata_array_name},
}};
""", file=out)

  print(f'''
pub const {event_ring_type.upper()}_EVENT_DEFAULT_FILE_NAME: &str =
    "monad-{event_ring_type}-events";
''', file=out)

def emit_module_file(module: ModuleInfo, out: TextIO):
  emit_module_prologue(module, out)

  if module.is_event_module:
    emit_event_enum_type(module, out)

  for type_info in module.type_defs.values():
    if isinstance(type_info, EnumTypeInfo):
      emit_enum_type(type_info, out)
    elif isinstance(type_info, AliasTypeInfo):
      emit_alias_type(type_info, out)
    elif isinstance(type_info, RecordTypeInfo):
      emit_struct_type(type_info, out)
    elif isinstance(type_info, (ExternalTypeInfo, EmptyTypeInfo)):
      pass # No code generation for these
    else:
      assert False, 'missing support for this type family'

  if module.is_event_module:
    emit_format_as_function(module, out)
    emit_event_metadata_array(module, out)

def emit_library_file(module_names: list[str], out: TextIO):
  for m in sorted(module_names):
    print(f'pub mod {m};', file=out)

def try_run_rustfmt(rustfmt_path: Optional[str], rustfmt_args: str,
                    source_path: pathlib.Path):
  if rustfmt_path is None:
    return
  cmd_args = [rustfmt_path, str(source_path)]
  if rustfmt_args:
    cmd_args.insert(1, rustfmt_args)
  subprocess.run(cmd_args, check=True, capture_output=True)

def rust_main(args: argparse.Namespace, module_map: Mapping[str, ModuleInfo]) -> int:
  rustfmt_args = ''
  if args.stdout and args.rustfmt:
    raise ValueError('--rustfmt is not compatible with --stdout;'
                     'pipe stdout to rustfmt instead')

  if args.rustfmt:
    if args.rustfmt[0] == '"':
      args.rustfmt = args.rustfmt[1:-1]
    fmt_cmd, _, rustfmt_args = args.rustfmt.partition(' ')
    fmt_cmd_path = shutil.which(fmt_cmd)
    if not fmt_cmd_path:
      raise ValueError(f'--rustfmt executable `{fmt_cmd}` not on PATH')
    args.rustfmt = fmt_cmd_path

  if args.path and not args.path.is_dir():
    raise ValueError(f'{args.path} is not a valid directory')

  lib_rs_module_names = list()
  for module_name, module in module_map.items():
    if module.is_external_only:
      continue

    lib_rs_module_names.append(module_name)
    if args.module and module_name not in args.module:
      continue

    if args.stdout:
      print(f'//! {module_name}.rs contents:', file=sys.stdout)
      emit_module_file(module, sys.stdout)
    else:
      with open(args.path / f'{module_name}.rs', 'wt') as out:
        emit_module_file(module, out)
      try_run_rustfmt(args.rustfmt, rustfmt_args, args.path / f'{module_name}.rs')

  # Emit a lib.rs file, if they want one
  if args.lib:
    if args.stdout:
      print(f'//! lib.rs contents:', file=sys.stdout)
      emit_library_file(lib_rs_module_names, sys.stdout)
    else:
      with open(args.path / 'lib.rs', 'wt') as out:
        emit_library_file(lib_rs_module_names, out)
      try_run_rustfmt(args.rustfmt, rustfmt_args, args.path / 'lib.rs')

  return 0

def register_backend(subparsers):
  p = subparsers.add_parser('rust',
      help='generate C type bindings for the Rust language')

  output_group = p.add_mutually_exclusive_group(required=True)

  output_group.add_argument('-s', '--stdout', action='store_true',
      help='write Rust source files to stdout, for debugging')

  output_group.add_argument('-p', '--path', action='store',
      type=pathlib.Path, metavar='<dir>',
      help='output directory where generated source code files will be written')

  p.add_argument('--lib', action='store_true', help='emit a lib.rs file')

  p.add_argument('-f', '--rustfmt', nargs='?',
      const='"rustfmt +nightly"', metavar='<rustfmt-command>',
      help='run rustfmt on the output, after it is produced')

  p.set_defaults(backend_main=rust_main)
